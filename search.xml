<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《大型网站技术架构》-- 大型网站核心架构要素]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08-03-CoreArchitecturalElementsofLargeWebsites%2F</url>
    <content type="text"><![CDATA[性能—响应时间决定用户浏览器端： 浏览器缓存； 使用页面压缩； PS：Gzip压缩效率非常高，通常可以达到70%的压缩率，也就是说，如果你的网页有30K，压缩之后就变成了9K左右。想要启用Gzip压缩，提高浏览速度，可以浏览这篇文章：http://www.chinaz.com/web/2012/1017/278682.shtml 合理布局页面； CSS：把样式表置于顶部；避免使用CSS表达式（expression_r）；使用外部JavaScript和CSS；削减JavaScript和CSS；用代替@import；避免使用滤镜； JavaScript：把脚本置于页面底部；使用外部JavaScript和CSS；削减JavaScript和CSS；剔除重复脚本；减少DOM访问；开发智能事件处理程序； 减少Cookie传输； CDN内容分发网络（Content Delivery Network，简称CDN）将加速内容分发至离用户最近的节点，缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性，解决网络带宽小、用户访问量大、网点分布不均等问题。详情请见百度百科：http://baike.baidu.com/view/8689800.htm?from_id=420951&amp;type=search&amp;fromtitle=CDN&amp;fr=aladdin 应用服务器端服务器本地缓存和分布式缓存； Memcached简介：http://baike.baidu.com/view/794242.htm Redis简介：http://baike.baidu.com/view/4595959.htm 服务器集群技术Web服务器集群、数据库服务器集群、分布式缓存服务器集群等等，通过部署多台服务器共同对外提供同类服务，提高整体处理能力。 数据库服务器端 索引：索引（index）是对数据库表中一个或多个列（例如，employee 表的姓氏 (name) 列）的值进行排序的结构。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。 PS：要注意的是，建立太多的索引将会影响更新和插入的速度，因为它需要同样更新每个索引文件。 缓存：数据库缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对数据库的物理数据源访问的频次，从而提高了应用的运行性能。 SQL优化：当一个基于数据库的应用程序运行起来很慢时，90%的可能都是由于数据访问程序的问题，要么是没有优化，要么是没有按最佳方法编写代码，因此你需要审查和优化你的数据访问/处理程序。具体可以浏览这篇文章：T- SQL性能优化详解 NoSQL：方兴未艾的NoSQL数据库通过优化数据模型、存储结构、伸缩性等手段在性能方面的优势日趋明显。 可用性—你能保证几个9？如何衡量可用性？全靠9来撑腰：几乎所有网站都承诺7*24小时可用，但事实上都不可能完全实现，总会有一些故障时间。那么，去除这些故障时间就是网站的总可用时间。换算成网站的可用性指标，以此衡量网站的可用性，例如某些知名网站可用性达到99.99%。 哪些手段提高可用性？ 核心：冗余-各服务器互相备份保证整体可用； 应用服务器端：通过负载均衡设备建立集群，其中一台宕机立即切换到其他服务器继续提供服务，这就保证了高可用性。 存储服务器端：需要对数据进行实时备份，当某台宕机立即将数据访问请求转换到其他服务器上，并进行数据恢复以保证数据高可用。 伸缩性—能屈能伸方为大丈夫衡量标准： 是否可以多态服务器构建集群？ 是否容易向集群中添加新服务器？ 加入服务器后是否能提供无差别服务？ 主要手段： 应用服务器：使用合适的负载均衡设备（硬件还是软件？F5还是LVS+KeepAlived）； 缓存服务器：改进缓存路由算法保证缓存数据的可访问性； 数据库服务器：通过路由区分等手段将多服务器组成一个集群； 扩展性—不痛不痒之间新业务就上线了衡量标准：增加新业务时是否可以实现对现有产品透明无影响（是否需要对现有业务进行修改匹配？）； 主要手段： 事件驱动架构：利用消息队列实现； 分布式服务：将业务和可复用服务分离； 安全性—妈妈再也不用担心的我的照片了何为安全性？保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取； 衡量标准：针对现存和潜在的攻击窃密手段，是否有可靠的应对策略；]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大型网站技术架构》-- 大型网站架构模式]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08-02-LargeWebsiteArchitectureModel%2F</url>
    <content type="text"><![CDATA[分层最常见的架构模式，将系统在横向维度上切分成几个部分，每个部分单一职责。网站一般分为三个层次：应用层、服务层和数据层，其具体结构如下图所示： 通过分层，一个庞大系统切分成不同部分，`便于分工合作和维护`。但是，分层架构也有一些挑战： 必须合理规划层次边界和接口； 禁止跨层次的调用及逆向调用。 分割分割是在纵向方面对软件进行切分-&gt;将不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，有助于软件开发和维护，还便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。 分布式 分布式应用和服务：应用和服务模块分布式部署，便于业务功能扩展； 分布式静态资源：JS、CSS、LOGO图片等资源独立部署，采用独立域名-&gt;动静分离； 分布式数据和存储：传统RDBMS分布式部署和NoSQL产品； 分布式计算：Hadoop及其MapReduce分布式计算框架，其特点是移动计算而不是移动数据。 集群多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。当某台服务器发生故障，负载均衡设备或者系统的失效转移机制将请求转发到集群中的其他服务器上，提高系统的可用性，即所谓的HA（高可用性）。 所以，在网站应用中，即使是访问量很小的分布式应用和服务，也至少要部署两台服务器构成一个小集群。 缓存缓存是改善软件性能的第一手段。在复杂的软件设计中，缓存几乎无处不在。 CDN：内容分发网络，缓存网站的一些静态资源； 反向代理：部署在网站的前端，最先访问到的就是反向代理服务器； 本地缓存：在应用服务器本地缓存热点数据，无需访问数据库； 分布式缓存：应用程序通过网络通信访问缓存数据； 网站应用中，缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力。 异步业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行进行协作。 异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站扩展新功能非常便利。 异步消息队列可以提高系统可用性、加快网站响应速度，消除并发访问高峰。 冗余要想保证在服务器宕机的情况下网站依然可以继续服务，不丢失数据，就需要一定程度的服务器冗余运行，数据冗余备份，这样当某台服务器宕机时，可以将其上的服务和数据访问转移到其他机器上。 数据库除了定期备份存档保存实现冷备份之外，为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步实现热备份。 自动化在无人值守的情况下，网站可以正常运行，一切都可以自动化是网站的理想状态。目前大型网站的自动化架构设计主要集中在发布运维方面。 发布部署过程自动化； 自动化代码管理； 自动化测试； 自动化安全监测； 安全 通过密码和手机校验码进行身份验证； 对登录、交易等操作进行加密； 使用验证码进行识别； 对于常见的XSS攻击、SQL注入、编码转换等进行防范； 对垃圾或敏感信息进行过滤； 对交易转账等操作进行风险控制； 总结好的设计绝对不是模仿，不是生搬硬套某个模式，而是对问题深刻理解之上的创造与创新，即使是“微创新”，也是让人耳目一新的似曾相识。山寨与创新的最大区别不在于是否抄袭，是否模仿，而在于对问题和需求是否真正理解与把握。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[When to Use What: REST, GraphQL, Webhooks, & gRPC]]></title>
    <url>%2F2019%2F07%2F05%2F2019-07-05-REST%2CGraphQL%2CWebhooks%2CgRPC%2F</url>
    <content type="text"><![CDATA[With all of the love and proclamations about REST, we can sometimes forget that it’s simply one of many options. REST is a very good standard for a wide variety of APIs, but there are other API design styles for more nuanced scenarios. To help API developers make sense of which API design style to use and for what situation, let’s look at REST within the context of three other options – gRPC, GraphQL, and Webhooks. We’ll offer real world examples of REST, GraphQL, gRPC, and Webhooks in practice, and analyze their strengths and weaknesses to highlight what makes each option a good choice. 文章转载 RESTREST is probably the most commonly known item in this piece, as it has become very common amongst web APIs. REST as a concept was first defined by Roy Fielding in his doctoral dissertation in the year 2000. He laid out the groundwork for an architectural system defined by a set of constraints for web services, using a stateless design ethos and a standardized approach to building web APIs. REST by its very nature is stateless, and is built in such a way that any web service that is compliant with REST can interact in a stateless manner with textual resource representations. These operations are usually defined using GET, POST, PUT, and other HTTP methodologies as a matter of standardized interactions. One of the chief properties of REST is the fact that it is hypermedia rich. Hypermedia and REST are so closely reliant, in fact, that Roy Fielding has stated that APIs are technically not RESTful if they do not support hypermedia. This ultimately means that in a REST API, the client and server are loosely coupled, which grants both clients and servers extreme amounts of freedom in resource manipulation. Due to this, rapid iteration, server evolution, resource provision elasticity, and other such elements are enabled and supported. REST supports a lot more than we’ll dive into here, but with a layered architecture, efficient caching, and high scalability, REST is a highly discoverable and highly morphable solution to a multitude of issues and constraints. The value of having standardized HTTP verbiage is hard to understate, providing context to the end user, and standardizing most interactions. All told, REST is a very efficient, effective, and powerful solution for the modern microservice API industry. More on REST: Is REST Still a Relevant API Style? Real-World Example: PayPalOne example of this type of API is the PayPal REST API. PayPal has a strong core business function — provide the integrated systems for payment processing. Accordingly, their APIs have to make this easy. Resources must be easily identifiable, calls must be understood with and without context, and most importantly, a variety of media must be supported in order to effectively handle a wide range of payment types and methodologies. To this end, the PayPal API is designed to be easy to understand and easy to integrate with. Look at this example, taken from their documentation, in which a call lists a range of activities within the API: 123curl -v -X GET https://api.sandbox.paypal.com/v1/activities/activities?start_time=2012-01-01T00:00:01.000Z&amp;amp;end_time=2014-10-01T23:59:59.999Z&amp;amp;page_size=10 -H "Content-Type: application/json" -H "Authorization: Bearer Access-Token" Here, we can see the hallmarks of an effective RESTful implementation. We can see a standard HTTP verbiage form in GET doing exactly what GET should do — retrieve a resource. The URI in this case is well defined as “activities”, and allows for specification of a time zone and in-line request constraints for page size. Additionally, the return is in a specified, known, hypermedia-supporting format. This is REST in a nutshell, and is an example of a use case in which a lightweight, stateless system is exactly what is needed to deliver the resources to the end client. gRPCWhile REST is decidedly modern, gRPC is actually a new take on an old approach known as RPC, or Remote Procedure Call. RPC is a method for executing a procedure on a remote server, somewhat akin to running a program on a friend’s computer miles from your workstation. This has its own benefits and drawbacks – these very drawbacks were key in the development and implementation of REST, in fact, alongside other issues inherent in systems like SOAP. A key difference between gRPC and REST is the way in which RPC defines its contract negotiation. Whereas REST defines its interactions through terms standardized in its requests, RPC functions upon an idea of contracts, in which the negotiation is defined and constricted by the client-server relationship rather than the architecture itself. RPC gives much of the power (and responsibility) to the client for execution, while offloading much of the handling and computation to the remote server hosting the resource. For this reason, RPC is very popular for IoT devices and other solutions requiring custom contracted communications for low-power devices. REST is often seen as being overly demanding of resources, whereas RPC can be used even in extremely low-power situations. gRPC is a further evolution on the RPC concept, and adds a wide range of features. The biggest feature added by gRPC is the concept of protobufs. Protobufs are language and platform neutral systems used to serialize data, meaning that these communications can be efficiently serialized and communicated in an effective manner. Additionally, gRPC has a very effective and powerful authentication system that utilizes SSL/TLS through Google’s token-based system. Lastly, gRPC is also open source, meaning that the system can be audited, iterated, forked, and more. More on gRPC: Exploring The gRPC Framework for Building Microservices Example APIs – Google Cloud, BugsnagIt’s difficult to demonstrate gRPC in the wild — this comes largely from the fact that, according to the gRPC documentation itself, gRPC is typically used in the “last mile of computing.” In other words, gRPC is usually the end system driving and facilitating communication between disparate services and APIs. Nonetheless, the gRPC documentation cites that, due to its transportability, gRPC is used within the mobile computing space, as well as an intermediary and processing system for data from the Google Cloud BigTable Client API, the Google Cloud PubSub API, and the Google Cloud Speech API. This makes sense, as the use of standard transport mechanisms and the relatively agile data load gRPC offers can be best utilized for streamlined, active, and repetitive communications. Another example of gRPC in production can be found with Bugsnag, a stability monitoring service. The Bugsnag engineering team found the initial design process smoother than building RESTfully. Eventually, however they found that the “barrier to entry for developing and testing gRPC was quite high,” due to a lack of tutorials and best practices. Overall, the latency improvements and decreased transport costs made using gRPC a huge success for Bugsnag. GraphQLGraphQL’s approach to the idea of client-server relationships is unique amongst these options, and is somewhat of a reversal of the traditional relationship. With GraphQL, the client determines what data they want, how they want it, and in what format they want it in. This is a reversal of the classic dictation from the server to the client, and allows for a lot of extended functionality. GraphQL is starkly different from REST, which is more an architecture than anything else, and from RPC, in which the contract is negotiated by client and server but largely defined by the resources themselves It should be noted that a huge benefit of GraphQL is the fact that, by default, it typically delivers the smallest possible request. REST, on the other hand, typically sends everything it has all at once by default – the most complete request, in other words. Because of this, GraphQL can be more useful in specific use cases where a needed data type is well-defined, and a low data package is preferred. That being said, GraphQL’s benefits are often somewhat oversold. The idea that you never have to version is derived from deprecating fields and replacing them with new ones, which is what REST evolution is concerned with. Thus, you shouldn’t think of GraphQL as “better” than REST or the “next step”, as it is often framed, but rather as an alternative option for a “new relationship between client and data”. Example API – GitHubOne example of GraphQL usage can be found in the GitHub API GraphQL API. While the initial RESTful API was powerful, and did what was requested, the GitHub team found that the REST API was inflexible. Speaking on the problem, the team said that the API responses “simultaneously sent too much data and didn’t include data that consumers needed,” which is the classic pain point that caused the development of GraphQL in the first place. Accordingly, GitHub needed a way to deliver their content to requesters without requiring multiple distinct, complex calls. They needed to allow users to morph their requests, stating what exactly they needed. And most importantly, they needed the API to still be capable of handling the basic requests that the bulk of their REST API already handled efficiently. To that end, Github added support for GraphQL, delivering these key functionalities. WebhooksWhile GraphQL is an option to extend an API, and gRPC is a re-tooling to a classical approach, Webhooks are an entirely different approach to resource provision than anything discussed here. A Webhook is relatively simple – simply put, it’s an HTTP POST that is triggered when an event occurs. This is a reversal of the classic client-server relationship — in the classic approach, the client requests data from the server, and the server then provisions that data for the client. Under the Webhook paradigm, the server updates a provisioned resource, and this then automatically sent to the client as an update. The server pushes this data. Thereby, the client becomes not a requester, but a passive receiver. Ultimately, this reversal can be used to facilitate a lot of communication that would otherwise require more complex requests and constant polling on the remote server. By simply receiving the resource without requesting it directly, you can update remote codebases, distribute resources easily, and even integrate into existing systems to update endpoints and other data concerning the API proper. Related: WebHooks vs WebSub: Which Is Better For Real-Time Event Streaming? Example API – Foursquare (and SendGrid)Webhooks are a relatively simple and effective offering, and thus, their implementation is equally simple and effective. The Foursquare method of using a webhook is essentially a flow in which the user “checks in,” prompting a webhook to push updated content to other systems and portals. In this way, the user can directly interact with the location that they are visiting while alerting others as to the nature of their relationship with the location via a client-resource analogy. As you get further into webhooks as an implementation, you’ll often see more complex integrations. For example, SendGrid uses webhooks to send event data updates to subscribing clients, alerting them to changes to a large number of variables. SendGrid even implements a hybridized webhook method to parse emails! Comparing Use Cases For REST, GraphQL, Webhooks, and gRPCAs you can plainly see, none of these options are truly “better” than the others, but instead fit into unique interaction scenarios. We can summarize these use cases as follows: REST: A stateless architecture for data transfer that is dependent on hypermedia. REST can tie together a wide range of resources that might be requested in a variety of formats for different purposes. REST is fundamentally concerned with stateless resource management, so it’s best used in such situations. Systems requiring rapid iteration and standardized HTTP verbiage will find REST best suited for their purposes. gRPC: A nimble and lightweight system for requesting data. gRPC, on the other hand, is best used when a system requires a set amount of data or processing routinely, and in which the requester is either low power or resource-jealous. The IoT is a great example of this. GraphQL: An approach wherein the user defines the expected data and format of that data. GraphQL is from Facebook, and that pedigree demonstrates its use case well — situations in which the requester needs the data in a specific format for a specific use. In those cases, those data formats and the relations between them are vitally important, and no other solution provides the same level of interconnected provision of data. Webhooks: Data updates to be served automatically, rather than requested. Finally, Webhooks are best used when the API in question primarily updates clients. While such APIs can also have other functions, even RESTful ones, the primary use of a Webhook microservice should be to update clients and provide updated, provisioned data upon the creation of the new, updated resource. Choosing amongst these specific options is really a matter of aligning your business functions with the appropriate approach, and ensuring that the systems in place respond within the given parameters. ConclusionChoosing a design approach is perhaps the most important decision made in early API development. It both structures the API, and impacts how the end user will interact with the resources behind the API itself. In other words, this is not just a choice of approach for the developer — this is a choice for how you are going to establish your relationship with your consumers. Ultimately, the choice of which solution you go with comes down to what fits your particular use case. Each solution has a very specific purpose, and as such, it’s not fair to say one is better than the other. It is, however, more accurate to say that some are better at doing their core functions than the other solutions — such as the case of many RESTful solutions attempting to mirror RPC functionality. Only you can determine which solution is best given your codebase. So, do your research and choose the correct approach from the get-go to reap some serious benefits. Your code will be leaner, more responsive, and tailored to the situation at hand.]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes vs Docker Swarm]]></title>
    <url>%2F2019%2F06%2F24%2F2019-06-24-k8sVSswarm%2F</url>
    <content type="text"><![CDATA[Kubernetes and Docker Swarm are probably two most commonly used tools to deploy containers inside a cluster. Both are created as helper tools that can be used to manage a cluster of containers and treat all servers as a single unit. However, they differ greatly in their approach. 文章转载 Kubernetes and Docker Swarm are probably two most commonly used tools to deploy containers inside a cluster. Both are created as helper tools that can be used to manage a cluster of containers and treat all servers as a single unit. However, they differ greatly in their approach. KubernetesKubernetes is based on Google’s experience of many years working with Linux containers. It is, in a way, a replica of what Google has been doing for a long time but, this time, adapted to Docker. That approach is great in many ways, most important being that they used their experience from the start. If you started using Kubernetes around Docker version 1.0 (or earlier), the experience with Kubernetes was great. It solved many of the problems that Docker itself had. We could mount persistent volumes that would allow us to move containers without loosing data, it used flannel to create networking between containers, it has load balancer integrated, it uses etcd for service discovery, and so on. However, Kubernetes comes at a cost. It uses a different CLI, different API and different YAML definitions. In other words, you cannot use Docker CLI nor you can use Docker Compose to define containers. Everything needs to be done from scratch exclusively for Kubernetes. It’s as if the tool was not written for Docker (which is partly true). Kubernetes brought clustering to a new level but at the expense of usability and steep learning curve. Docker SwarmDocker Swarm took a different approach. It is a native clustering for Docker. The best part is that it exposes standard Docker API meaning that any tool that you used to communicate with Docker (Docker CLI, Docker Compose, Dokku, Krane, and so on) can work equally well with Docker Swarm. That in itself is both an advantage and a disadvantage at the same time. Being able to use familiar tools of your own choosing is great but for the same reasons we are bound by the limitations of Docker API. If the API doesn’t support something, there is no way around it through Swarm API and some clever tricks need to be performed. We’ll explore those two tools in more details based on their setup and features they provide for running containers in a cluster. Setting UpSetting up Docker Swarm is easy, straightforward and flexible. All we have to do is install one of the service discovery tools and run the swarm container on all nodes. Since the distribution itself is packed as a Docker container, it works in the same way no matter the operating system. We run the swarm container, expose a port and inform it about the address of the service discovery. It could hardly be easier than that. We can even start using it without any service discovery tool, see whether we like it and when our usage of it becomes more serious, add etcd, Consul or some of the other supported tools. Kubernetes setup is quite more complicated and obfuscated. Installation instructions differ from OS to OS and provider to provider. Each OS or a hosting provider comes with its own set of instructions each of them having a separate maintenance team with a separate set of problems. As example, if you choose to try it out with Vagrant, you are stuck with Fedora. That does not mean that you cannot run it with Vagrant and, let’s say, Ubuntu or CoreOS. You can, but you need to start searching for instructions outside the official Kubernetes Getting Started page. Whatever your needs are, it’s likely that the community has the solution but you still need to spend some time searching for it and hoping that it works from the first attempt. The bigger problem is that the installation relies on a bash script. That would not be a big deal in itself if we would not live in the era where configuration management is a must. We might not want to run a script but make Kubernetes be part of our Puppet, Chef or Ansible definitions. Again, this can be overcome as well. You can find Ansible playbooks for running Kubernetes or you can write your own. None of those issues are a big problem but, when compared with Swarm, they are a bit painful. With Docker we were supposed not to have installation instructions (aside from a few docker run arguments). We were supposed to run containers. Swarm fulfils that promise and Kubernetes doesn’t. While some might not care about which discovery tool is used, I love the simplicity behind Swarm and the logic “batteries included but removable”. Everything works out-of-the-box but we still have the option to substitute one component with the other. Unlike Swarm, Kubernetes is opinionated tool. You need to live with the choices it made for you. If you want to use Kubernetes, you have to use etcd. I’m not trying to say that etcd is bad (quite contrary) but if you prefer, for example, to use Consul you’re in a very complicated situation and would need to use one for Kubernetes and the other for the rest of your service discovery needs. Another thing I dislike about Kubernetes is its need to know things in advance, before the setup. You need to tell it the addresses of all your nodes, which role each of them has, how many minions there are in the cluster and so on. With Swarm, we just bring up a node and tell it to join the network. Nothing needs to be set in advance since the information about the cluster is propagated through gossip. Set up might not be the most important difference between those tools. No matter which tool you choose, sooner or later everything will be up and running and you’ll forget any trouble you might have had during the process. You might say that we should not choose one tool over the other only because one is easier to set up. Fair enough. Let’s move on and speak about differences in how you define containers that should be run with those tools. Running ContainersHow do you define all the arguments needed for running Docker containers with Swarm? You don’t! Actually, you do but not in any form or way different from the way you were defining them before Swarm. If you are used to run containers through Docker CLI, you can continue using it with (almost) the same commands. If you prefer to use Docker Compose to run containers, you can continue using it to run them inside the Swarm cluster. Whichever way you’re used to run your containers, chances are that you can continue doing the same with Swarm but on a much larger scale. Kubernetes requires you to learn its CLI and configurations. You cannot use docker-compose.yml definitions you created earlier. You’ll have to create Kubernetes equivalents. You cannot use Docker CLI commands you learned before. You’ll have to learn Kubernetes CLI and, likely, make sure that the whole organization learns it as well. No matter which tool you choose for deployments to your cluster, chances are you are already familiar with Docker. You are probably already used to Docker Compose as a way to define arguments for the containers you’ll run. If you played with it for more than a few hours, you are using it as a substitute for Docker CLI. You run containers with it, tail their logs, scale them, and so on. On the other hand, you might be a hard-core Docker user who does not like Docker Compose and prefer running everything through Docker CLI or you might have your own bash scripts that run containers for you. No matter what you choose, it should work with Docker Swarm. If you adopt Kubernetes, be prepared to have multiple definitions of the same thing. You will need Docker Compose to run your containers outside Kubernetes. Developers will continue needing to run containers on their laptops, your staging environments might or might not be a big cluster, and so on. In other words, once you adopt Docker, Docker Compose or Docker CLI are unavoidable. You have to use them one way or another. Once you start using Kubernetes you will discover that all your Docker Compose definitions (or whatever else you might be using) need to be translated to Kubernetes way of describing things and, from there on, you will have to maintain both. With Kubernetes everything will have to be duplicated resulting in higher cost of maintenance. And it’s not only about duplicated configurations. Commands you’ll run outside of the cluster will be different from those inside the cluster. All those Docker commands you learned and love will have to get their Kubernetes equivalents inside the cluster. Guys behind Kubernetes are not trying to make your life miserable by forcing you to do things “their way”. The reason for such big differences is in a different approaches Swarm and Kubernetes are using to tackle the same problem. Swarm team decided to match their API with the one from Docker. As a result, we have (almost) full compatibility. Almost everything we can do with Docker we can do with Swarm as well only on a much larger scale. There’s nothing new to do, no configurations to be duplicated and nothing new to learn. No matter whether you use Docker CLI directly or go through Swarm, API is (more or less) the same. The negative side of that story is that if there is something you’d like Swarm to do and that something is not part of the Docker API, you’re in for a disappointment. Let us simplify this a bit. If you’re looking for a tool for deploying containers in a cluster that will use Docker API, Swarm is the solution. On the other hand, if you want a tool that will overcome Docker limitations, you should go with Kubernetes. It is power (Kubernetes) against simplicity (Swarm). Or, at least, that’s how it was until recently. But, I’m jumping ahead of myself. The only question unanswered is what those limitations are. Two of the major ones were networking and persistent volumes. Until Docker Swarm release 1.0 we could not link containers running on different servers. Actually, we still cannot link them but now we have multi-host networking to help us connect containers running on different servers. It is a very powerful feature. Kubernetes used flannel to accomplish networking and now, since the Docker release 1.9, that feature is available as part of Docker CLI. Another problem were persistent volumes. Docker introduced them in release 1.9. Until recently, if you persist a volume, that container was tied to the server that volume resides. It could not be moved around without, again, resorting to some nasty tricks like copying volume directory from one server to another. That in itself is a slow operation that defies the goals of tools like Swarm. Besides, even if you have time to copy a volume from one to the other server, you do not know where to copy since clustering tools tend to treat your whole datacenter as a single entity. You containers will be deployed to a location most suitable for them (least number of containers running, most CPUs or memory available, and so on). Now we have persistent volumes supported by Docker natively. Both networking and persistent volumes problems were one of the features supported by Kubernetes for quite some time and the reason why many were choosing it over Swarm. That advantage disappeared with Docker release 1.9. The ChoiceWhen trying to make a choice between Docker Swarm and Kubernetes, think in following terms. Do you want to depend on Docker itself solving problems related to clustering. If you do, choose Swarm. If something is not supported by Docker it will be unlikely that it will be supported by Swarm since it relies on Docker API. On the other hand, if you want a tool that works around Docker limitations, Kubernetes might be the right one for you. Kubernetes was not built around Docker but is based on Google’s experience with containers. It is opinionated and tries to do things in its own way. The real question is whether Kubernetes’ way of doing things, which is quite different from how we use Docker, is overshadowed by advantages it gives. Or, should we place our bets into Docker itself and hope that it will solve those problems? Before you answer those questions, take a look at the release 1.9. We got persistent volumes and software networking. We also got unless-stopped restart policy that will manage our unwanted failures. Now there are three things less of a difference between Kubernetes and Swarm. Actually, these days there are very few advantages Kubernetes has over Swarm. On the other hand, Swarm uses Docker API meaning that you get to keep all your commands and Docker Compose configurations. Personally, I’m placing my bets on Docker engine getting improvements and Docker Swarm running on top of it. The difference between the two is very small. Both are production ready but Swarm is easier to set up, easier to use and we get to keep everything we built before moving to the cluster; there is no duplication between cluster and non-cluster configurations. My recommendation is to go with Docker Swarm. Kubernetes is too opinionated, hard to set up, too different from Docker CLI/API and at the same time it doesn’t have real advantages over Swarm since the Docker release 1.9. That doesn’t mean that there are no features available in Kubernetes that are not supported by Swarm. There are feature differences in both directions. However, those differences are, in my opinion, not major ones and the gap is getting smaller with each Docker release. Actually, for many use cases there is no gap at all while Docker Swarm is easier to set up, learn and use.]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18.04优化]]></title>
    <url>%2F2019%2F06%2F23%2F2019-06-23-ubuntu%2F</url>
    <content type="text"><![CDATA[Linux 系统用来用去还是发现ubuntu用的最舒服，毕竟用了从14.04 一直用到了18.04 。用了三年多了。下面就直接记录下。我这边优化系统的全部命令，方便下次装机使用。 更换源重命名源1$ sudo mv /etc/apt/sources.list /etc/apt/sources.list.mv 建立阿里源1$ sudo vi /etc/apt/sources.list 复制以下内容 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 更新源1$ sudo apt update &amp;&amp; sudo apt upgrade 改目录名称12$ export LANG=en_US$ xdg-user-dirs-gtk-update 下载git1$ apt install git 配置git12$ git config --global user.name "ziv" $ git config --global user.email "abc.ziv@hotmail.com" 配置SSH秘钥12$ ssh-keygen -t rsa -C "abc.ziv@hotmail.com"$ cat ~/.ssh/id_rsa.pub 安装VSCode12$ wget https://vscode.cdn.azure.cn/stable/c7d83e57cd18f18026a8162d042843bda1bcf21f/code_1.35.1-1560350270_amd64.deb$ sudo dpkg -i code_1.35.1-1560350270_amd64.deb 安装 搜狗拼音12$ wget http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb$ sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb 安装搜狗拼音依赖12345$ sudo apt install -f$ locale$ check-language-suppor## 把出现的所有依赖都安装$ sudo reboot 安装谷歌浏览器12$ wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb$ sudo dpkg -i google-chrome-stable_current_amd64.deb 安装oh-my-zsh12345678910111213141516171819$ sudo apt-get install zsh$ chsh -s /bin/zsh $ sudo vi /etc/passwd## 把第一行的/bin/bash改成/bin/zsh，这个是root用户的## 把最后一行的/bin/bash改成/bin/zsh，这个应该是每台电脑的登录用户名+计算机名组成的。$ sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)"$ sudo reboot# 查看主题$ ls ~/.oh-my-zsh/themes# 自动提示插件zsh-autosuggestions$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions# 语法高亮zsh-syntax-highlighting使用以下命令安装$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting# 修改主题 配置插件$ vi ~/.zshrcplugins=(git zsh-syntax-highlighting zsh-autosuggestions)ZSH_THEME="主题" 推荐：steeef ys# 更新配置$ source ~/.zshrc 安装shadowsocks-qt512345$ sudo add-apt-repository ppa:hzwhuang/ss-qt5$ vi /etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list## bionic(18.04版本代号)改成xenial(16.04版本代号)$ sudo apt update$ sudo apt install shadowsocks-qt5 安装百度网盘12$ wget https://github.com/liuzhuoling2011/baidupcs-web/releases/download/3.6.7/BaiduPCS-Go-3.6.7-linux-amd64.zip$ unzip BaiduPCS-Go-3.6.7-linux-amd64.zip 安装thunderbird邮箱1sudo apt install thunderbird 安装印象笔记1sudo apt install nixnote2 -y 安装flameshot截图工具12wget https://github.com/lupoDharkael/flameshot/releases/download/v0.6.0/flameshot_0.6.0_bionic_x86_64.debsudo dpkg -i flameshot_0.6.0_bionic_x86_64.deb 安装rememberthemilk123wget https://www.rememberthemilk.com/download/linux/debian/pool/main/r/rememberthemilk/rememberthemilk_1.1.13_amd64.debsudo dpkg -i rememberthemilk_1.1.13_amd64.debsudo apt install -f WPS12wget https://wdl1.cache.wps.cn/wps/download/ep/Linux2019/8392/wps-office_11.1.0.8392_amd64.debsudo dpkg -i wps-office_11.1.0.8392_amd64.deb]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构的特点及演化]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-18-TechnicalArchitectureofLargeWebsite01%2F</url>
    <content type="text"><![CDATA[大型网站的特点 高并发、大流量：PV(page view)量巨大 高可用：7*24小时不间断服务 海量数据：需要存储、管理海量数据，需要使用大量服务器 用户分布广泛，网络情况复杂：网络运营商 安全环境恶劣：黑客的攻击 需求快速变更，发布频繁：快速适应市场，满足用户需求 渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始的，渐进地发展起来的 大型网站架构演化过程初始阶段的网站架构 在初始阶段，访问量并不大，所以应用程序、数据库、文件等所有的资源都在一台服务器上。 应用服务和数据服务分离 随着业务的发展，就会发现一台服务器抗不过来了，所以将应用服务器与数据（文件、数据库）服务器分离。三台服务器对硬件资源的要求各不相同：应用服务器需要更快的CPU，文件服务器需要更大的磁盘和带宽，数据库服务器需要更快速的磁盘和更大的内存。分离之后，三个服务器各司其职，也方便针对性的优化。 使用缓存改善网站性能 缓存的使用无处不在，缓存的根本目的是加快访问速度。当数据库的访问压力过大的时候，就可以考虑使用缓存了。网站使用的缓存可以分为两种: 缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。 使用应用服务器集群改善网站的并发处理能力 随着业务的发展，单个应用服务器一定会成为瓶颈，应用服务器实现集群是网站可伸缩集群架构设计中较为简单成熟的一种。后面也会提到，将应用服务器设计为无状态的（没有需要保存的上下文信息），就可以通过增加机器，使用负载均衡来scale out。 数据库读写分离 即使使用了缓存，但在缓存未命中、或者缓存服务时效的情况下，还是需要访问数据库，这个时候就需要数据库的读写分离：主库提供写操作，从库提供读服务。注意，在上图中增加了一个数据访问模块，可以对应用层透明数据库的主从分离信息。 使用反向代理和CDN 加速网站晌应 CDN和反向代理其实都是缓存，区别在于CDN 部署在网络提供商的机房；而反向代理则部署在网站的中心机房。使用CDN 和反向代理的目的都是尽旱返回数据给用户， 一方面加快用户访问速度，另一方面也减轻后端服务器的负载压力。 使用分布式文件系统和分布式数据库系统 单个物理机的磁盘是有限的，单个关系数据库的处理能力也是有上限的，所以需要分布式文件存储与分布式数据库。当然，也需要”统一数据访问模块“，使得应用层不用关心文件、数据的具体位置。值得一提的事，关系型数据库自身并没有很好的水平扩展方案，因此一般都需要一个数据库代理层，如cobar、mycat。 使用NoSQL 和搜索引擎 很多应用并一定适合用关系数据库存储，更加灵活的NoSql能更加方便的解决一些问题，而且NoSQL天然就支持分布式。专门的搜索引擎在提供更优质服务的同时，也大大减轻了数据库的压力。 业务拆分 将一个网站拆分成许多不同的应用， 每个应用独立部署维护。应用之间可以通过一个超链接建立关系(在首页上的导航链接每个都指向不同的应用地址) ，也可以通过消息队列进行数据分发， 当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统 分布式服务 既然每一个应用系统都需要执行许多相同的业务操作， 比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。 通过服务的分布式，各个应用能更好的独立发展，实现了从依赖模块到依赖服务的过渡。将通用的公共服务独立出来，也方便做服务管控，比如对各个应用的服务请求进行监控，在高峰时期限制、关闭某些应用的访问等。 大型网站架构价值观与设计误区价值观核心价值随网站所需灵活应对，大型网站不是从无到有一步就搭建好一个大型网站，而是能够伴随小型网站业务的渐进发展，慢慢地演化成一个大型网站。 驱动力量网站的业务发展—业务成就了技术，事业成就了人，而不是相反。 设计误区 一味追随大公司的解决方案。 为了技术而技术，常见问题。 企图用技术解决所有问题：技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO使用记录]]></title>
    <url>%2F2019%2F06%2F06%2F2019-06-06-HEXO%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 更新yay 1$ yay -Syy 下载 git nodejs npm1234$ yay -S git nodejs npm$ git --version$ node -v$ npm -v 更换npm源 1$ sudo npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo12$ sudo cnpm install -g hexo-cli$ hexo -v 创建项目（blog）12345678910111213$ hexo init blog$ cd blog#安装依赖$ npm install$ npm audit fix# 生成$ hexo g# 清缓存$ hexo clean# 部署$ hexo d# 启动$ hexo s 下载主题123456789101112131415161718192021222324252627282930313233$ git clone https://github.com/theme-next/hexo-theme-next themes/next# 配置主题$ vi _config.yml# 设置主题theme : next# 设置语音language: zh-CN# 设置头像avatar:...url: /images/avatar.png# 更新主题$ cd themes/next$ git pull# 开启标签/分类$ vi _config.yml tags: /tags/ || tags categories: /categories/ || th$ cd ../# 配置标签$ hexo new page tags$ vi hexo/source/tags/index.mdtitle: 标签date: 2014-12-22 12:39:04type: "tags"comments: false#配置分类$ hexo new page categories$ vi hexo/source/categories/index.mdtitle: 分类date: 2014-12-22 12:39:04type: "categories"comments: false github 发布1234567$ npm install hexo-deployer-git --save$ vi _config.ymldeploy： type： git repo： &lt;repository url&gt; #https：//bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch： [branch] #published message： [message] #leave this blank]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro系统使用记录]]></title>
    <url>%2F2019%2F06%2F05%2F2019-06-05-manjaro%2F</url>
    <content type="text"><![CDATA[Manjaro是一款基于Arch Linux、对用户友好、全球排名第1的Linux发行版。 在Linux圈，Arch的确是一个异常强大的发行版。它有3个无与伦比的优势： 滚动更新可以使软件保持最新； AUR软件仓库有着世界上最齐全的Linux软件 丰富的wiki和活跃的社区让所有问题都可以快速得到满意的答案。 查看版本 1$ screenfetch 错误：无法注册 ‘archlinuxcn’ 数据库 (数据库已登记) 1$ sudo vi /etc/pacman.conf 添加源 1$ sudo pacman-mirrors -i -c China -m rank 增加archlinuxcn库和antergos库 1$ echo -e "\n[archlinuxcn]\nSigLevel = TrustAll\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/\$arch\n\n[antergos]\nSigLevel = TrustAll\nServer = https://mirrors.tuna.tsinghua.edu.cn/antergos/\$repo/\$arch\n"|sudo tee -a /etc/pacman.conf 更新 1$ sudo pacman -Syy 安装archlinuxcn签名钥匙&amp;antergos签名钥匙 1$ sudo pacman -S --noconfirm archlinuxcn-keyring antergos-keyring 安装搜狗输入法 1$ sudo pacman -S --noconfirm fcitx-im fcitx-configtool fcitx-sogoupinyin 配置搜狗变量 1$ sudo echo -e "export GTK_IM_MODULE=fcitx\nexport QT_IM_MODULE=fcitx\nexport XMODIFIERS=@im=fcitx"&gt;&gt;~/.xprofile 错误：搜狗输入法异常！请删除.config/SogouPY 并重启 1$ sogou-qimpanel sogou-qimpanel: error while loading shared libraries: libfcitx-qt.so.0: cannot open shared object file: No such file or directory 1$ sudo pacman -S fcitx-qt4 安装快照工具 1$ sudo pacman -S timeshift 安装git 123$ sudo pacman -S git$ git config --global user.name "ziv" $ git config --global user.email "abc.ziv@hotmail.com" 安装谷歌浏览器 1$ sudo pacman -S google-chrome 安装AUR助手yay 1234567891011 $ sudo pacman -S yay# 手动编译$ git clone https://aur.archlinux.org/yay.git$ cd yay$ makepkg -si# 安装$ yay -S `软件`# 更新$ yay -Ss# 卸载$ yay -Rs `软件` 安装网易云音乐 1$ yay -S netease-cloud-music 安装oh-my-zsh 123456789101112131415$ wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh# 切换zsh$ chsh -s /bin/zsh# 查看主题$ ls ~/.oh-my-zsh/themes# 自动提示插件zsh-autosuggestions$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions# 语法高亮zsh-syntax-highlighting使用以下命令安装$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting# 修改主题 配置插件$vi ~/.zshrcplugins=(git zsh-syntax-highlighting zsh-autosuggestions)ZSH_THEME="主题" 推荐：steeef# 更新配置$ source ~/.zshrc incr也是zsh自动补全插件 下载自动补全插件http://mimosa-pudica.net/src/incr-0.2.zsh 放到oh-my-zsh的插件库中.oh-my-zsh/plugins/创建incr文件夹放到该文件夹中 在.zshrc中添加在.zshrc文件末尾添加下面这行source ~/.oh-my-zsh/plugins/incr/incr*.zsh 重启命令行 安装印象笔记 12345$ yay -S nixnote2# 设置File-&gt;Add Another Userserver Yinxiang BijiTools-&gt;Synchronize 安装debtap（转换deb工具） 1234567$ yay -S debtap# 更新debtap数据库$ debtap -u# 转换deb包$ debtap -q 安装包.deb# 执行安装$ yay -U 安装包.pkg.tar.xz 安装TIM 1$ yay -S deepin.com.qq.office 安装微信 1$ sudo yay -S electronic-wechat 更改英文目录 123456$ sudo pacman -S xdg-user-dirs-gtk$ export LANG=en_US$ xdg-user-dirs-gtk-update$ #然后会有个窗口提示语言更改，更新名称即可$ export LANG=zh_CN.UTF-8$ #然后重启电脑如果提示语言更改，保留旧的名称即可 安装截图工具flameshot1$ yay -S flameshot 安装thunderbird邮箱 1$ yay -S thunderbird 安装VScode 1$ yay -S visual-studio-code-bin 安装baiduPCS-web(百度网盘WEB版本)下载地址：https://github.com/liuzhuoling2011/baidupcs-web/releases 123cd #到软件所在的目录chmod a+x BaiduPCS-Go./BaiduPCS-Go 安装shadowsocks1$ yay -S shadowsocks-qt5 # 输入2 系统代理系统设置 -&gt; 代理 -&gt; Use manually specified proxy cofinguration -&gt; SOCKS Proxy:127.0.0.1 Prot:1080 浏览器代理以 Chrome 为例，安装 SwitchyOmega 插件代理。 Github 下载 SwitchyOmega：https://github.com/FelisCatus/SwitchyOmega/releases/ Chrome 打开 chrome://extensions/，把插件托进去安装。]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-数据结构(ZVAL)]]></title>
    <url>%2F2018%2F11%2F17%2F2018-11-17-ZVAL%2F</url>
    <content type="text"><![CDATA[介绍PHP是弱类型语言,在PHP代码中声明或使用变量的时候,并不需要强制指明其数据类型.在PHP内核中定义的变量类型: 123456/* Zend/zend_type.h : line 304 */#define IS_UNDEF 0#define IS_NULL 1...#define IS_PTR 17#define _IS_ERROR 20 zvalPHP底层设计了一个zval(“Zend value”的缩写)的数据结构,可以用来表示任意类型的PHP值,因此,它可能是所有PHP中最重要的结构.本节介绍zvals及其使用背后的基本概念. 1234567/* Zend/zend_type.h */typedef union _zend_value &#123;...&#125; zend_value;struct _zval_struct &#123;...&#125;; 虽然看起来变得好大, 但其实你仔细看, 全部都是联合体, 这个新的zval在64位环境下,现在只需要16个字节(2个指针size), 它主要分为俩个部分, value和扩充字段, 而扩充字段又分为u1和u2俩个部分, 其中u1是type info, u2是各种辅助字.其中value部分, 是一个size_t大小(一个指针大小), 可以保存一个指针, 或者一个long, 或者一个double.而type info部分则保存了这个zval的类型. 扩充辅助字段则会在多个其他地方使用, 比如next, 就用在取代Hashtable中原来的拉链指针, 这部分会在以后介绍HashTable的时候再来详解. 从PHP7开始, 对于在zval的value字段中能保存下的值, 就不再对他们进行引用计数了, 而是在拷贝的时候直接赋值, 这样就省掉了大量的引用计数相关的操作, 这部分类型有: IS_LONG IS_DOUBLE当然对于那种根本没有值, 只有类型的类型, 也不需要引用计数了: IS_NULL IS_FALSE IS_TRUE而对于复杂类型, 一个size_t保存不下的, 那么我们就用value来保存一个指针, 这个指针指向这个具体的值, 引用计数也随之作用于这个值上, 而不在是作用于zval上了. 所以, 在PHP7开始, 我们移除了MAKE_STD_ZVAL/ALLOC_ZVAL宏, 不再支持存堆内存上申请zval. 函数内部使用的zval要么来自外面输入, 要么使用在栈上分配的临时zval. 操作zval对zval的操作定义了很多宏,这维持了一个抽象层次,使意图更清晰,将来的PHP版本zval的内部改变了还可以兼容. 123456789101112131415//不正确zval zv = ...if (zv_ptr-&gt;type == IS_LONG) &#123; php_printf("此变量为长整形,值为 %ld\n", zv-&gt;value.lval);&#125; else ...//推荐使用宏操作,zval zv = ...if (Z_TYPE zv ) == IS_LONG ) &#123; php_printf (“此变量为长整形,值为 ％ld \ n ” , Z_LVAL_P zv ));&#125; else ...//宏有_P后缀表示操作的是zval指针Z_TYPE(zv); // 获取zval类型 = zv.typeZ_TYPE_P(zv_ptr); // 获取指针指向的zval类型= zv_ptr-&gt;type zval.value 相关宏1234567891011121314No. 名称 变量名 含义 访问宏1 zend_long lval 整数(integer) Z_LVAL(zval)2 double dval 浮動小数点数(float/double) Z_DVAL(zval)3 zend_refcounted *counted 引用计数 Z_COUNTED(zval)4 zend_string *str 字符串 Z_STR(zval)5 zend_array *arr 数组 Z_ARR(zval)6 zend_object *obj 对象 Z_OBJ(zval)7 zend_resource *res 资源 Z_RES(zval)8 zend_reference *ref 引用 Z_REF(zval)9 zend_ast_ref *ast 抽象構文木 Z_AST(zval)10 zval *zv zval指针 Z_INDIRECT(zval)11 void *ptr 任意类型指针 Z_PTR(zval)12 zend_class_entry *ce 类 Z_CE(zval)13 zend_function *func 函数 Z_FUNC(zval) zval 相关宏12345678910111213141516171819ZVAL_UNDEF(z): 表示zval被销毁ZVAL_NULL(z): 设置为NULLZVAL_FALSE(z): 设置为falseZVAL_TRUE(z): 设置为trueZVAL_BOOL(z, b): 设置为布尔型,b为IS_TRUE、IS_FALSE,与上面两个等价ZVAL_LONG(z, l): 设置为整形,l类型为zend_long,如:zval z; ZVAL_LONG(&amp;z, 88);ZVAL_DOUBLE(z, d): 设置为浮点型,d类型为doubleZVAL_STR(z, s): 设置字符串,将z的value设置为s,s类型为zend_string*,不会增加s的refcount,支持interned stringsZVAL_NEW_STR(z, s): 同ZVAL_STR(z, s),s为普通字符串,不支持interned stringsZVAL_STR_COPY(z, s): 将s拷贝到z的value,s类型为zend_string*,同ZVAL_STR(z, s),这里会增加s的refcountZVAL_ARR(z, a): 设置为数组,a类型为zend_array*ZVAL_NEW_ARR(z): 新分配一个数组,主动分配一个zend_arrayZVAL_NEW_PERSISTENT_ARR(z): 创建持久化数组,通过malloc分配,需要手动释放ZVAL_OBJ(z, o): 设置为对象,o类型为zend_object*ZVAL_RES(z, r): 设置为资源,r类型为zend_resource*ZVAL_NEW_RES(z, h, p, t): 新创建一个资源,h为资源handle,t为type,p为资源ptr指向结构ZVAL_REF(z, r): 设置为引用,r类型为zend_reference*ZVAL_NEW_EMPTY_REF(z): 新创建一个空引用,没有设置具体引用的valueZVAL_NEW_REF(z, r): 新创建一个引用,r为引用的值,类型为zval* 在代码中查看zval参考资料:https://github.com/pangudashu/php7-internal/blob/master/7/var.md https://net-newbie.com/phpext/7-zval.html https://github.com/laruence/php7-internal/blob/master/zval.md]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-数据结构(SAPI)]]></title>
    <url>%2F2018%2F10%2F13%2F2018-10-13-SAPI%2F</url>
    <content type="text"><![CDATA[在PHP生命周期的各个阶段，一些与服务相关的操作都是通过SAPI接口实现。这些内置实现的物理位置在PHP源码的SAPI目录。这个目录存放了PHP对各个服务器抽象层的代码，例如命令行程序的实现，Apache的mod_php模块实现以及fastcgi的实现等等。 SAPI分别在FPM和CLI下是如何运行的？ SAPI12345test.php&lt;?php $temp = $_POST; print_r($temp);?&gt; FPM 123456789static sapi_module_struct cgi_sapi_module = &#123; "fpm_fcgi", ... sapi_cgibin_ub_write, sapi_cgibin_flush, ... sapi_cgi_read_post, ...&#125;; CLI 123456789static sapi_module_struct cgi_sapi_module = &#123; "cli", ... sapi_cli_ub_write, sapi_cli_flush, ... NULL, ...&#125;; sapi模块结构体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct _sapi_module_struct &#123; char *name; char *pretty_name; int (*startup)(struct _sapi_module_struct *sapi_module);//PHP被调用的时候,这个函数会被调用执行 int (*shutdown)(struct _sapi_module_struct *sapi_module);//PHP调用结束的时候,这个函数会被调用执行 int (*activate)(void);//每个request开始时会执行,进行一些初始化,资源分配的事务 int (*deactivate)(void);//每个request结束时会执行 size_t (*ub_write)(const char *str, size_t str_length);//这个hanlder告诉了Zend,如何输出数据,对于mod_php来说,这个函数提供了一个向response数据写的接口,而CLI只是简单的写到stdout void (*flush)(void *server_context);//这个是提供给zend的刷新缓存的函数句柄,对于CLI来说,只是简单的调用系统提供的fflush; zend_stat_t *(*get_stat)(void);//这部分用来让Zend可以验证一个要执行脚本文件的state,从而判断文件是否据有执行权限等等. char *(*getenv)(char *name, size_t name_len);//为Zend提供了一个根据name来查找环境变量的接口,对于mod_php5来说,当我们在脚本中调用getenv的时候,就会间接的调用这个句柄.CLI和CGI很类似,直接调用父级是Shell, 所以,只是简单的调用了系统提供的genenv: void (*sapi_error)(int type, const char *error_msg, ...) ZEND_ATTRIBUTE_FORMAT(printf, 2, 3);//错误处理函数 int (*header_handler)(sapi_header_struct *sapi_header, sapi_header_op_enum op, sapi_headers_struct *sapi_headers);//这个函数会在我们调用PHP的header()函数的时候被调用. int (*send_headers)(sapi_headers_struct *sapi_headers);//这个函数会在要真正发送header的时候被调用,一般来说,就是当有任何的输出要发送之前: void (*send_header)(sapi_header_struct *sapi_header, void *server_context);//这个用来单独发送每一个header size_t (*read_post)(char *buffer, size_t count_bytes);//这个句柄指明了如何获取POST的数据,CLI是从stdin中读取POST DATA的, char *(*read_cookies)(void);//这个句柄指明了如何获取cookies的数据 void (*register_server_variables)(zval *track_vars_array);//这个函数用以给$_SERVER变量中添加变量,CLI在此函数中注册了PHP_SELF,SCRIPT_FILENAME等server变量: void (*log_message)(char *message, int syslog_type_int);//用来输出错误信息,对于CLI来说,只是简单的输出到stderr double (*get_request_time)(void);//获取请求时间,只有apach2自定义了,默认为获取当前时间 void (*terminate_process)(void);//没有任何SAPI用到,无用代码 //STANDARD_SAPI_MODULE_PROPERTIES char *php_ini_path_override; void (*default_post_reader)(void); void (*treat_data)(int arg, char *str, zval *destArray); char *executable_location; int php_ini_ignore; int php_ini_ignore_cwd; int (*get_fd)(int *fd); int (*force_http_10)(void); int (*get_target_uid)(uid_t *); int (*get_target_gid)(gid_t *); unsigned int (*input_filter)(int arg, char *var, char **val, size_t val_len, size_t *new_val_len); void (*ini_defaults)(HashTable *configuration_hash); int phpinfo_as_text; char *ini_entries; const zend_function_entry *additional_functions; unsigned int (*input_filter_init)(void);&#125;; cli_sapi_module 的定义1234567891011121314151617181920212223242526272829static sapi_module_struct cli_sapi_module = &#123; "cli", /* name */ "Command Line Interface", /* pretty name */ php_cli_startup, /* startup */ php_module_shutdown_wrapper, /* shutdown */ NULL, /* activate */ sapi_cli_deactivate, /* deactivate */ sapi_cli_ub_write, /* unbuffered write */ sapi_cli_flush, /* flush */ NULL, /* get uid */ NULL, /* getenv */ php_error, /* error handler */ sapi_cli_header_handler, /* header handler */ sapi_cli_send_headers, /* send headers handler */ sapi_cli_send_header, /* send header handler */ NULL, /* read POST data */ sapi_cli_read_cookies, /* read Cookies */ sapi_cli_register_variables, /* register server variables */ sapi_cli_log_message, /* Log message */ NULL, /* Get request time */ NULL, /* Child terminate */ STANDARD_SAPI_MODULE_PROPERTIES&#125;;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-扩展(Extensions)]]></title>
    <url>%2F2018%2F08%2F20%2F2018-08-20-PhpExtensions%2F</url>
    <content type="text"><![CDATA[PHP资料 http://www.phpinternalsbook.com/ PHP下载 官网下载:https://secure.php.net/downloads.php GITHUB: http://github.com/php/php-src 构建依赖程序在继续之前,您可能应该与包管理器一起安装一些基本构建依赖项(默认情况下,您可能已经安装了前三个): gcc或其他一些编译器套件. libc-dev,它提供C标准库,包括头文件. make,这是PHP使用的构建管理工具. autoconf(2.59或更高版本),用于生成配置脚本. automake(1.4或更高),它生成 Makefile.in文件. libtool帮助管理共享库. bison(2.4或更高版本),用于生成PHP解析器. re2c(可选),用于生成PHP词法分析器.由于git存储库已经包含一个生成的词法分析器,所以只需要修改它就需要re2c. 在Debian/Ubuntu上,您可以使用以下命令安装所有这些:sudo apt-get install build-essential autoconf automake libtool bison re2c 配置选项讲解:./configure --help | less使用--enable-NAME和--disable-NAME开关编译哪些扩展和SAPI . 如果扩展或SAPI具有外部依赖关系,则需要使用--with-NAME和--without-NAME. 如果NAME所需的库 不在默认位置(例如,因为您自己编译),则可以使用--with-NAME = DIR指定其位置. 如果选项是--enable-NAME或--with-NAME说明该选项默认是关闭的.如果是--disable-NAME或--without-NAME说明该选项默认是开启的. 我们要进行的配置和编译命令:./configure --disable-all --enable-cli --enable-debug (--enable-debug启用调试模式,具有多重效果: 编译将使用 -g运行以生成包括行号、变量的类型和作用域、函数名字、函数参数和函数的作用域等源文件特性的调试信息. 另外使用-O0,会让gcc编译时不对代码优化. 此外,调试模式定义了 ZEND_DEBUG宏,它将启动引擎中的各种调试助手.除其他事项外,还将报告内存泄漏以及某些数据结构的不正确使用.) make -jN (N为CPU数量,作用:make --help查看)PHP内核源码目录结构php-744.1.4 ├── build //源码编译相关文件 └── ext //官方扩展目录,包括了绝大多数PHP的函数的定义和实现 └── main //PHP核心基本文件,这里和Zend引擎不一样,Zend引擎主要实现语言最核心的语言运行环境. └── pear //“PHP 扩展与应用仓库”,包含PEAR的核心文件. └── sapi //包含了各种服务器抽象层的代码,例如apache的mod_php,cgi,fastcgi以及fpm等等接口. └── tests //PHP的测试脚本集合,包含PHP各项功能的测试文件 └── TSRM //PHP的线程安全是构建在TSRM库之上的,PHP实现中常见的*G宏通常是对TSRM的封装,TSRM(Thread Safe Resource Manager)线程安全资源管理器. └── win32 //Windows平台相关的一些实现,比如sokcet的实现在Windows下和*Nix平台就不太一样,同时也包括了Windows下编译PHP相关的脚本. └── Zend //Zend引擎的实现目录,比如脚本的词法语法解析,opcode的执行以及扩展机制的实现等等. └── .gdbinit //gdb命令编写脚本 (gdb) source /home/laruence/package/php-5.2.14/.gdbinit (gdb) zbacktrace └── CODING_STANDARDS //PHP编码标准 └── config.guess //由automake产生,两个用于目标平台检测的脚本 └── config.log //configure执行时生成的日志文件 └── config.nice //configure执行时生成,记录了上次执行configure时带的详细参数 └── config.status //configure执行时生成,实际调用编译工具构建软件的shell脚本 └── config.sub //由automake产生,两个用于目标平台检测的脚本 └── configure //配置并生成makefile └── configure.in //autoreconf创建,开发者维护,用于生成configure └── CREDITS //开发人员名单 └── EXTENSIONS //扩展说明(维护状态,维护人员,版本,适用系统..) └── LICENSE //发布协议 └── php.ini-development //PHP开发环境示例配置文件 └── php.ini-production //PHP生产环境示例配置文件 └── README.EXT_SKEL //构建扩展脚本说明 └── README.GIT-RULES //GIT提交时的规则 └── README.namespaces //命名空间说明 └── README.PARAMETER_PARSING_API //新的参数解析函数说明 └── README.REDIST.BINS //PHP中引用到的其它程序协议说明 └── README.RELEASE_PROCESS //PHP发布过程说明 └── README.SELF-CONTAINED-EXTENSIONS//创建一个内建的PHP扩展 └── README.STREAMS //PHP Streams(流概念) 说明 └── README.SUBMITTING_PATCH //介绍如何提交PHP的增强功能或修补程序 └── README.TESTING //测试说明(run-tests.php) └── README.TESTING2 //测试说明(server-tests.php) └── README.UNIX-BUILD-SYSTEM //PHP编译系统V5概述 └── README.WIN32-BUILD-SYSTEM //WIN32编译说明 └── run-test.php //测试脚本 └── server-test.php //测试脚本 └── sesrver-test-config.php //测试脚本 └── UPGRADING //版本更新说明 └── UPGRADING.INTERNALS //内部更新说明PHP扩展分类PHP中的扩展分为两类:PHP扩展、Zend扩展,对内核而言这两个分别称之为:模块(module)、扩展(extension),我们主要介绍是PHP扩展,也就是模块. 加载区别: PHP扩展(又名PHP“模块”)使用“extension = test.so”行加载到INI文件中 Zend扩展使用“zend_extension = test.so”行加载到INI文件中 Zend扩展比PHP扩展更复杂,因为它们有更多的钩子,而且更接近Zend引擎及其虚拟机(整个PHP源代码中最复杂的部分).Zend扩展例子如:OPCache,XDebug,phpdbg,Zend扩展通常用来处理两种任务:调试器和剖析器.如果您的目标是“只是”向PHP 添加一些新概念(函数,类,常量等),那么您将使用PHP扩展,但如果需要更改PHP的当前行为,可能Zend扩展将会更好.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache内存溢出的分析与解决]]></title>
    <url>%2F2018%2F06%2F13%2F2018-06-27-OutOfMemory%2F</url>
    <content type="text"><![CDATA[总结Apache长时间占用内存大的问题的根本原因在MySQL查询时间过长。请开启慢查询功能，去解决! 修改Apache治标不治本~ 查看版本 1234httpd -vServer version: Apache/2.4.29 (Unix)Server built: Jan 11 2018 22:38:20 修改Apache在prefork工作模式参数 1sudo vi /usr/local/httpd/conf/extra/httpd-mpm.conf 具体: 12345678910111213# prefork MPM&lt;IfModule mpm_prefork_module&gt;StartServers 5#apache启动时候默认开始的子进程数MinSpareServers 5#最小的闲置子进程数MaxSpareServers 10#最大的闲置子进程数MaxRequestWorkers 250#MaxRequestWorkers设置了允许同时的最大接入请求数量。任何超过MaxRequestWorkers限制的请求将进入等候队列在apache2.3.1以前的版本MaxRequestWorkers被称为MaxClients旧的名字仍旧被支持。MaxConnectionsPerChild 100 #重点!#设置的是每个子进程可处理的请求数。每个子进程在处理了“MaxConnectionsPerChild”个请求后将自动销毁。0意味着无限即子进程永不销毁。虽然缺省设为0可以使每个子进程处理更多的请求但如果设成非零值也有两点重要的好处1、可防止意外的内存泄漏。2、在服务器负载下降的时侯会自动减少子进程数。因此可根据服务器的负载来调整这个值。在Apache2.3.9之前称之为MaxRequestsPerChild。&lt;/IfModule&gt; 重启apache 1/etc/init.d/httpd restart 注1:MaxRequestWorkers是这些指令中最为重要的一个设定的是 Apache可以同时处理的请求是对Apache性能影响最大的参数。如果请求总数已达到这个值可通过ps -ef|grep http|wc -l来确认那么后面的请求就要排队直到某个已处理请求完毕。这就是系统资源还剩下很多而HTTP访问却很慢的主要原因。虽然理论上这个值越大可以处理的请求就越多建议将初始值设为(以Mb为单位的最大物理内存/2),然后根据负载情况进行动态调整。比如一台4G内存的机器那么初始值就是4000/2=2000。s 注2:prefork 控制进程在最初建立“StartServers”个子进程后为了满足MinSpareServers设置的需要创建一个进程等待一秒钟继续创建两 个再等待一秒钟继续创建四个……如此按指数级增加创建的进程数最多达到每秒32个直到满足MinSpareServers设置的值为止。这种模式 可以不必在请求到来时再产生新的进程从而减小了系统开销以增加性能。MaxSpareServers设置了最大的空闲进程数如果空闲进程数大于这个 值Apache会自动kill掉一些多余进程。这个值不要设得过大但如果设的值比MinSpareServers小Apache会自动把其调整为 MinSpareServers+1。如果站点负载较大可考虑同时加大MinSpareServers和MaxSpareServers。 注3:ServerLimit和MaxClientsMaxRequestWorkers有什么区别呢? 是因为在apache1时代控制最大进程数只有MaxClients这个参数并且这个参数最大值为256并且是写死了的试图设置为超过256是无效的这是由于apache1时代的服务器硬件限制的。但是apache2时代由于服务器硬件的升级硬件已经不再是限制所以使用ServerLimit这个参数来控制最大进程数ServerLimit值&gt;=MaxClient值才有效。ServerLimit要放在MaxClients之前值要不小于MaxClients。 常用命令查看请求总数 1ps -ef|grep http|wc -l 查看平均负载(loadavg) 1$cat /proc/loadavg 查看TCP连接数 1netstat -ant | grep :80 | wc -l 查看系统运行情况 12top shift + M]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vultr VPS搭建SS(ShadowSocks)教程]]></title>
    <url>%2F2018%2F06%2F12%2F2018-06-12-VPS%2F</url>
    <content type="text"><![CDATA[国外服务器的购买这里我选择的是Vultr，对比了很多国外的服务器，这个蛮靠谱的，且搭建成功后看youtube1080p完全无压力。 Vultr服务器价格Vultr服务器按小时计费,最低0.004美元/h,算起来2.5美元/月，且destory掉服务器是不收费的，所以不用担心如果暂时没有使用还一直扣费的问题，如下图所示： 最低价格的服务器是512M的内存，500G的带宽，只能说99%的情况下完全够用了！ 注册Vultr首先打开Vultr链接，点击Create Account 充值Vultr注册完成之后就是充值，Vultr提供4种充值方式，如下图： 这里我选择支付宝，因为方便快捷，但是最低消费10美元，也不多，60多人民币，如下图： 选择VPS的位置首先，位置很重要！我们如何选择呢，当然有科学的办法，ping它！ Vultr的服务器有很多位置，下面我测试的东京节点和新加坡节点的数据如下： 这么看来还是东京的节点速度比较好，当然这个因人而异，在中国不同的地理位置访问国外不同位置的服务器速度也不一样。（下面提供了下载地址,下载下来双击运行即可）。 测速脚本下载地址：点我下载 测速.bat 脚本内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@echo offecho ===========================================echo 东京ping hnd-jp-ping.vultr.comecho ============================================echo 新加坡ping sgp-ping.vultr.comecho ===========================================echo (AU) Sydney, Australia[悉尼]ping syd-au-ping.vultr.comecho ===========================================echo 德国 法兰克福ping fra-de-ping.vultr.comecho ===========================================echo 荷兰 阿姆斯特丹ping ams-nl-ping.vultr.comecho ===========================================echo 英国 伦敦ping lon-gb-ping.vultr.comecho ===========================================echo 法国 巴黎ping par-fr-ping.vultr.comecho ===========================================echo 美东 华盛顿州 西雅图ping wa-us-ping.vultr.comecho ===========================================echo 美西 加州 硅谷ping sjo-ca-us-ping.vultr.comecho ===========================================echo 美西 加州 洛杉矶ping lax-ca-us-ping.vultr.comecho ===========================================echo 美东 芝加哥Chicago, Illinois[美东 芝加哥]ping il-us-ping.vultr.comecho ===========================================echo 美中 德克萨斯州 达拉斯ping tx-us-ping.vultr.comecho ===========================================echo 美东 新泽西ping nj-us-ping.vultr.comecho ===========================================echo 美东 乔治亚州 亚特兰大ping ga-us-ping.vultr.comecho ===========================================echo 美东 佛罗里达州 迈阿密ping fl-us-ping.vultr.com pause 创建VPS左侧菜单栏Servers，点击+，如下图： 选择VPS的位置，如下图： 选择操作系统和价格，如下图： 点击最下面的Deploy Now，如下图： 创建成功 VPS的信息安装成功之后，点击Manage 可以看到你购买的VPS的信息，如下图所示： ping一下ip地址，100ms多一点，这个速度相当可以了，如下图： 下载Shell当然是选择先连接它了，我们选择的工具是XShell。下载地址：Xshell下载 下载完成之后安装，下一步即可 接着选择免费为家庭/学校 语言选择中文： 连接VPS打开Xshell，选择文件-&gt;新建，输入VPS的IP，IP地址就在Vultr的管理页面上，如下图所示： 点击确定，输入用户名，默认应该为root，如下图： 接着输入密码： 连接成功： 快速搭建ShadowSocks(二选一)一键安装在Xshell中依次运行以下命令 12345wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 接着按照提醒输入你的密码，端口和加密方式，如下图： 然后可以去听首歌~，成功安装之后有你配置的信息显示，记住这些信息，然后跳过下面的手动安装部分，直接去看客户端连接部分即可，如下图： 以上脚本来源于秋水逸冰 手动安装在XShell的控制台输入： 123curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot;python get-pip.py 一个个的来，如下图： 安装ShadowSocks123pip install --upgrade pippip install shadowsocks 创建ShadowSocks配置文件单端口1vi /etc/shadowsocks.json 输入以下内容，然后点ESC后输入:wq保存退出 123456&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;server_port&quot;: 2018, &quot;password&quot;: &quot;12345678&quot;, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 多端口（可选，配置了单端口就不要配置这个）多端口的配置文件如下： 1234567891011&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;port_password&quot;: &#123; &quot;8381&quot;: &quot;password1&quot;, &quot;8382&quot;: &quot;password2&quot;, &quot;8383&quot;: &quot;password3&quot;, &quot;8384&quot;: &quot;password4&quot; &#125;, &quot;timeout&quot;: 300, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 配置防火墙1systemctl stop firewalld.service 启动ShadowSocks服务 1ssserver -c /etc/shadowsocks.json -d start 下面的是关闭，启动成功之后不要执行 关闭ShadowSocks服务1ssserver -c /etc/shadowsocks.json -d stop 连接ShadowSocks，体会科学上网的魅力Windows客户端下载地址：Shadowsocks 下载完成之后解压打开，如下图所示： 按照你自己的配置完成之后，点击确定，然后在托盘中右键这个小飞机，启动系统代理，灰色的小飞机就会亮起来，如下图： 然后就可以畅游网络了~ 测试地址： 谷歌 Youtube 推特 安卓连接下载地址：shadowsocks.apk 配置和windows差不多，配置完成后点击右上角的开启按钮即可，如下图： IOS连接参考链接：http://www.360doc.com/content/17/0614/06/37032448_662846097.shtml MAC 连接ShadowsocksX-2.6.3.dmg]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laradock到laravel]]></title>
    <url>%2F2018%2F03%2F12%2F2018-03-12-Laradock%20%2F</url>
    <content type="text"><![CDATA[Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 前置依赖 Git Docker（最新版本） Docker-Compose 12345678910# step 1: 安装必要的一些系统工具sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# step 2: 安装GPG证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# Step 3: 写入软件源信息sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"# Step 4: 更新并安装 Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce laradock1 -下载laradock 1git clone https://github.com/Laradock/laradock.git 2 -创建配置文件 12cd laradockcp env-example .env 3 -更换docker源 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://pg6cpimx.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 4 -启动服务 1docker-compose up -d nginx mysql redis 5 -访问你的网站 http://127.0.0.1 6 -停止容器 1docker-composer down laravel1 -查看容器并进入容器 12docker-compose psdocker-compose exec workspace bash 2 -更改composer源 1234567# 修改composer.json文件"repositories": &#123; "packagist": &#123; "type": "composer", "url": "https://packagist.phpcomposer.com" &#125; &#125; 3 -composer安装laravel安装器 1composer global require "laravel/installer" 4 -创建laravel项目blog 1/root/.composer/vendor/bin/laravel new blog 5 -退出容器 1exit 6 -配置域名并访问laravel 123456789# 修改配置文件 laradock/nginx/sites/laravel.confcd nginx/sites/cp laravel.conf.example laravel.conf# 修改配置root /var/www/blog/public;# 修改本地hosts文件vi /etc/hosts# 添加127.0.0.1 laravel.test 7 -重启容器 1docker-compose restart 现在可以访问 http://laravel.test/ 看到你的laravel项目了！ Ps:MySQL没有指定镜像源 12docker-composer up -d mysqlERROR: Service ‘mysql’ failed to build: Please provide a source image with `from` prior to commit 请更换docker的源。（阿里源可用） MySQL连不上或者提示密码错误 1#2002 - php_network_getaddresses: getaddrinfo failed: Name does not resolve &amp;mdash; The server is not responding (or the local server's socket is not correctly configured). 8.0默认加密方式导致的，更换MySQL版本。 laradock/.evn MYSQL_VERSION=5.7 docker-compose build mysql 更改DATA_SAVE_PATH=~/.laradock/data目录权限。]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说事物(第二天)]]></title>
    <url>%2F2017%2F10%2F28%2F2017-10-28-transactionTwo%2F</url>
    <content type="text"><![CDATA[隔离性（扩展:MVCC/SNAPSHOT ISOLATION） 读已提交 读未提交 可重复读 序列化读 快照隔离界别 用新的方式实现传统意义上读为提交的场景，同时保证可序列化的隔离级别。 写&gt;读时会增加系统成本 Mvcc适合读写比率比较高的情况 持久性（扩展:持久性保证策略） RAID* 如何保证数据同时写到两块磁盘 每一次请求都要刷磁盘性能过低，将请求打包统一发送到快存储 直接写入内存 优点：IOPS高 缺点：丢数据 Group commit 优点：保证系统的持久性和吞吐量 缺点:请求延迟提升 单机事务的典型异常应对策略 业务属性不匹配-回滚 系统DOWN机回复 重启后进入recovery 提交后的事务单元继续完成提交 未提交事务单元回滚 事务的调优原则 在不影响业务应用的前提下 减少锁的覆盖范围 Myisam表锁-&gt;Innodb行锁 原子锁-&gt;MVCC多版本 增加锁上可并行线程数 读锁写锁分离，允许并行读取数据 多线程并行读取 乐观锁/悲观锁 悲观锁-适合并发争抢比较严重的场景 是线程到blocking状态,通知信息OK状态切换回等待状态,需要不停的换入换出. 乐观锁-适合并发争抢比较不太严重的场 事务单元扩展Tow Phase lock(2PL) 死锁扩展-U锁更新锁-更新对只读情况，升级写锁 MVCC拾遗乐观锁并发方案: 让版本低的并发更新回滚 优势：并发低时性能好 代价：并发高时失败率高，需要不断重试]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[细说事物(第一天)]]></title>
    <url>%2F2017%2F08%2F20%2F2017-08-20-transactionOne%2F</url>
    <content type="text"><![CDATA[事务简介事务就是锁和并发的结合体. 优势:容易理解 劣势:性能较低 扩展 - `DRDS/TDDL‵ ACID保证事务的完整性 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持久性（Durability） 单个事务单元 商品要建立一个基于GMT_Modified的索引 从数据库读取一行记录 向数据库写入一行记录,同时更新这记录的所有索引 删除整张表 一组事务单元 Bob-&gt;Smith 100元 Smith-&gt;Joe 100元 Joe-&gt;Bob 100元 事务产生的原因事务单元之间的Happen-before关系 读写 写读 读读 写写 排队法序列化读写 优势:不需要冲突控制 劣势:慢速设备 事务单元 ->读 ->读 ->写 ->读 ->写 ->写 ->读 排他锁针对同一单元的访问进行控制 事务单元1 ->读 ->读 ->写 ->读 ->写 ->写 ->读 事务单元2 ->写 ->读 ->写 ->读 ->写 ->读 ->读 读写锁针对读读场景进行优化 事务单元1 ->写 ->读 ->写 ->读 ->写 ->写 ->读 事务单元2 ->读 ->读 ->读 MVCC本质上来说就是copy on write,能够做到写不阻塞读 事务单元1 ->写 ->写 ->写 ->写 ->写 ->写 ->写 事务单元2 ->读 ->读 ->读 ->读 事务单元3 ->读 ->读 事务处理谁先谁后在MMVC中一个读请求应该读哪一个写之后的数据? SCN(Oracle) Trx_id(Innodb) 故障恢复 业务属性不匹配 系统崩溃 死锁和死锁检测死锁产生的原因 两个线程 不同方向 相同资源 死锁的解决方法 降低隔离界别 碰撞检测 等锁超时]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简聊CGI,FastCGI,PHP-CGI,PHP-FPM之间的关系]]></title>
    <url>%2F2017%2F07%2F19%2F2017-07-19-fpm%2F</url>
    <content type="text"><![CDATA[概述FPM(FastCGI Process Manager)是PHP FastCGI运行模式的一个进程管理器，从它的定义可以看出，FPM的核心功能是进程管理，那么它用来管理什么进程呢？这个问题就需要从FastCGI说起了。 你(PHP)去和爱斯基摩人(web服务器，如 Apache、Nginx)谈生意.你说中文(PHP代码)，他说爱斯基摩语(C代码)，互相听不懂，怎么办？那就都把各自说的话转换成英语(FastCGI 协议)吧。怎么转换呢？你就要使用一个翻译机(PHP-FPM) (当然对方也有一个翻译机，那个是他自带的)我们这个翻译机是最新型的，老式的那个（PHP-CGI）被淘汰了。不过它(PHP-FPM)只有年轻人（Linux系统）会用，老头子们（Windows系统）不会摆弄它，只好继续用老式的那个。 CGI是干嘛的？CGI是为了保证web server传递过来的数据是标准格式的，方便CGI程序的编写者. web server（比如说nginx）只是内容的分发者。比如，如果请求/index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。好了，如果现在请求的是/index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解析器来处理，那么他会把这个请求简单处理后交给PHP解析器。Nginx会传哪些数据给PHP解析器呢？url要有吧，查询字符串也得有吧，POST数据也要有，HTTP header不能少吧，好的，CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。仔细想想，你在PHP代码中使用的用户从哪里来的。 当web server收到/index.php这个请求后，会启动对应的CGI程序，这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。 CGI是个协议，跟进程什么的没关系。那fastcgi又是什么呢？Fastcgi是用来提高CGI程序性能的。 提高性能，那么CGI程序的性能问题在哪呢？”PHP解析器会解析php.ini文件，初始化执行环境”，就是这里了。标准的CGI对每个请求都会执行这些步骤（不闲累啊！启动进程很累的说！），所以处理每个时间的时间会比较长。这明显不合理嘛！那么Fastcgi是怎么做的呢？首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。 PHP-FPM是什么呢？PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)对于PHP 5.3.3之前的php来说，是一个补丁包[1] ，旨在将FastCGI进程管理整合进PHP包中。如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。 大家都知道，PHP的解释器是php-cgi。php-cgi只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理（皇上，臣妾真的做不到啊！）所以就出现了一些能够调度php-cgi进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。好了PHP-FPM也是这么个东东，在长时间的发展后，逐渐得到了大家的认可（要知道，前几年大家可是抱怨PHP-FPM稳定性太差的），也越来越流行。 FastCGI的不足?因为是多进程，所以比CGI多线程消耗更多的服务器内存，PHP-CGI解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存数。 Nginx 0.8.46+PHP 5.2.14(FastCGI)服务器在3万并发连接下，开启的10个Nginx进程消耗150M内存（15M10=150M），开启的64个php-cgi进程消耗1280M内存（20M64=1280M），加上系统自身消耗的内存，总共消耗不到2GB内存。如果服务器内存较小，完全可以只开启25个php-cgi进程，这样php-cgi消耗的总内存数才500M。上面的数据摘自Nginx 0.8.x + PHP 5.2.13(FastCGI)搭建胜过Apache十倍的Web服务器(第6版)。 PHP-CGI的不足? php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启。 直接杀死php-cgi进程，php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>watch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP数组和对象相互转换]]></title>
    <url>%2F2017%2F06%2F19%2F2017-06-19-conversion%2F</url>
    <content type="text"><![CDATA[最近面试了很多PHP程序员，我出了这道题目，没几个做出来的。我很好奇，这也是项目中也经常能遇到的一个问题。所以顺便就记录一下。 题目array(&#39;foo&#39; =&gt; &#39;bar&#39;,&#39;one&#39; =&gt; &#39;two&#39;,&#39;three&#39; =&gt; &#39;four&#39;)把这个数组转成对象，然后在把对象转成数组。 答案123456789101112131415161718192021222324/** * 对象转数组 * @param unknown $obj 对象 */function objectToArray($obj)&#123; $arr = is_object($obj) ? get_object_vars($obj) : $obj; if(is_array($arr))&#123; return array_map(__FUNCTION__, $arr); &#125;else&#123; return $arr; &#125;&#125;/** * 数组转对象 * @param unknown $arr */function arrayToObject($arr)&#123; if(is_array($arr))&#123; return (object) array_map(__FUNCTION__, $arr); &#125;else&#123; return $arr; &#125;&#125; 扩展get_object_var($object) 返回一个数组。获取$object对象中的属性，组成一个数组。 123456789class person&#123; public $name="王小明"; public $age = 18; public $birth = 19910506;&#125;$p = new person();print_r(get_object_vars($p));# 输出：Array ( [name] =&gt; 王美人 [age] =&gt; 25 [birth] =&gt; 19910506 )]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL聚合索引与非聚合索引]]></title>
    <url>%2F2017%2F05%2F30%2F2017-05-30-clusteredIndex%2F</url>
    <content type="text"><![CDATA[基本介绍聚集索引聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相同，聚集索引有着更快的检索速度。 非聚集索引一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。 优劣势优点 1.可以把相关数据保存在一起，如：实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户全部邮件，如果没有使用聚集索引，则每封邮件都可能导致一次磁盘IO 2.数据访问更快，聚集索引将索引和数据保存在同一个btree中，因此从聚集索引中获取数据通常比在非聚集索引中查找要快 3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值 缺点 1.聚簇数据最大限度地提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚集索引也没有什么优势了 2.插入速度严重依赖于插入顺序，按照主键的顺序插入是加载数据到innodb表中速度最快的方式，但如果不是按照主键顺序加载数据，那么在加载完成后最好使用1optimize table`命令重新组织一下表 3.更新聚集索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置 4.基于聚集索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题，当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的磁盘空间 innodb和myisam物理存储的数据分布对比myisam： 是按照数据插入的顺序存储在磁盘上的，myisam中的主键索引和二级索引在结构上并没有什么不同，主键索引就是一个名为primary的唯一非空索引。 innodb： 因为innodb支持聚集索引，所以使用非常不同的方式存储同样的数据，innodb聚集索引包含了整个表的数据，而不是只有索引，因为在Innodb中，聚集索引就是表，所以不像myisam那样需要独立的行存储。聚集索引的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针以及所有剩余列的值，如果主键是一个列前缀索引，innodb也会包含完整的主键列和剩下的列的值。 还有一点和myisam不同的是，innodb的二级索引和聚集索引很不同，innodb二级索引的叶子节点中存储的不是行指针，而是主键值，并以此作为指向行的指针，这样的策略减少了当出现行移动或者数据页的分裂时二级索引的维护工作，使用主键值当做指针会让二级索引占用更多的空间，换来的好处是，innodb在移动行时无须更新二级索引中的这个指针。 何时使用聚集索引或非聚集索引 动作描述 使用聚集索引 使用非聚集索引 列经常被分组排序 应 应 返回某范围内的数据 应 不应 一个或极少不同值 不应 不应 小数目的不同值 应 不应 大数目的不同值 不应 应 频繁更新的列 不应 应 外键列 应 应 主键列 应 应 频繁修改索引列 不应 应 总结： 聚集索引就字典的首字母查询 非聚集索引就是字典的边盘部首查询 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript小技巧]]></title>
    <url>%2F2017%2F05%2F14%2F2017-05-14-javascriptTechnic%2F</url>
    <content type="text"><![CDATA[1) 使用!!将变量转换成布尔类型有时，我们需要检查一些变量是否存在，或者它是否具有有效值，从而将它们的值视为true。对于做这样的检查，你可以使用||（双重否定运算符），它能自动将任何类型的数据转换为布尔值，只有这些变量才会返回false：0，null，&quot;&quot;，undefined或NaN，其他的都返回true。我们来看看这个简单的例子： 1234567891011function Account(cash) &#123; this.cash = cash; this.hasMoney = !!cash;&#125;var account = new Account(100.50); console.log(account.cash); // 100.50 console.log(account.hasMoney); // truevar emptyAccount = new Account(0); console.log(emptyAccount.cash); // 0 console.log(emptyAccount.hasMoney); // false 在这个例子中，如果account.cash的值大于零，则account.hasMoney的值就是true。 2) 使用+将变量转换成数字这个转换超级简单，但它只适用于数字字符串，不然就会返回NaN（不是数字）。看看这个例子： 12345function toNumber(strNumber) &#123; return +strNumber;&#125;console.log(toNumber("1234")); // 1234 console.log(toNumber("ACB")); // NaN 这个转换操作也可以作用于Date，在这种情况下，它将返回时间戳： 1console.log(+new Date()) // 1461288164385 3) 短路条件如果你看到过这种类似的代码: 123if (conected) &#123; login();&#125; 那么你可以在这两个变量之间使用&amp;&amp;（AND运算符）来缩短代码。例如，前面的代码可以缩减到一行： 1conected &amp;&amp; login(); 你也可以用这种方法来检查对象中是否存在某些属性或函数。类似于以下代码： 1user &amp;&amp; user.login(); 4) 使用||设置默认值在ES6中有默认参数这个功能。为了在旧版浏览器中模拟此功能，你可以使用||（OR运算符），并把默认值作为它的第二个参数。如果第一个参数返回false，那么第二个参数将会被作为默认值返回。看下这个例子： 1234567891011function User(name, age) &#123; this.name = name || "Oliver Queen"; this.age = age || 27;&#125;var user1 = new User(); console.log(user1.name); // Oliver Queen console.log(user1.age); // 27var user2 = new User("Barry Allen", 25); console.log(user2.name); // Barry Allen console.log(user2.age); // 25 5) 在循环中缓存array.length这个技巧非常简单，并且在循环处理大数组时能够避免对性能造成巨大的影响。基本上几乎每个人都是这样使用for来循环遍历一个数组的： 123for (var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]);&#125; 如果你使用较小的数组，那还好，但是如果处理大数组，则此代码将在每个循环里重复计算数组的大小，这会产生一定的延迟。为了避免这种情况，你可以在变量中缓存array.length，以便在循环中每次都使用缓存来代替array.length： 1234var length = array.length; for (var i = 0; i &lt; length; i++) &#123; console.log(array[i]);&#125; 为了更简洁，可以这么写： 123for (var i = 0, length = array.length; i &lt; length; i++) &#123; console.log(array[i]);&#125; 6) 检测对象中的属性当你需要检查某些属性是否存在，避免运行未定义的函数或属性时，这个技巧非常有用。如果你打算编写跨浏览器代码，你也可能会用到这个技术。例如，我们假设你需要编写与旧版Internet Explorer 6兼容的代码，并且想要使用document.querySelector()来通过ID获取某些元素。 但是，在现代浏览器中，这个函数不存在。所以，要检查这个函数是否存在，你可以使用in运算符。看下这个例子： 12345if ('querySelector' in document) &#123; document.querySelector("#id");&#125; else &#123; document.getElementById("id");&#125; 在这种情况下，如果在document中没有querySelector函数，它就会使用document.getElementById()作为代替。 7) 获取数组的最后一个元素Array.prototype.slice（begin，end）可以用来裁剪数组。但是如果没有设置结束参数end的值的话，该函数会自动将end设置为数组长度值。我认为很少有人知道这个函数可以接受负值，如果你将begin设置一个负数的话，你就能从数组中获取到倒数的元素： 1234var array = [1, 2, 3, 4, 5, 6]; console.log(array.slice(-1)); // [6] console.log(array.slice(-2)); // [5,6] console.log(array.slice(-3)); // [4,5,6] 8) 数组截断这个技术可以锁定数组的大小，这对于要删除数组中固定数量的元素是非常有用的。例如，如果你有一个包含10个元素的数组，但是你只想获得前五个元素，则可以通过设置array.length = 5来阶段数组。看下这个例子： 12345var array = [1, 2, 3, 4, 5, 6]; console.log(array.length); // 6 array.length = 3; console.log(array.length); // 3 console.log(array); // [1,2,3] 9) 全部替换String.replace()函数允许使用String和Regex来替换字符串，这个函数本身只能替换第一个匹配的串。但是你可以在正则表达式末尾添加/g来模拟replaceAll()函数： 123var string = "john john"; console.log(string.replace(/hn/, "ana")); // "joana john" console.log(string.replace(/hn/g, "ana")); // "joana joana" 10) 合并数组如果你需要合并两个数组，你可以使用Array.concat()函数： 123var array1 = [1, 2, 3]; var array2 = [4, 5, 6]; console.log(array1.concat(array2)); // [1,2,3,4,5,6]; 但是，这个函数对于大数组来说不并合适，因为它将会创建一个新的数组并消耗大量的内存。在这种情况下，你可以使用Array.push.apply（arr1，arr2），它不会创建一个新数组，而是将第二个数组合并到第一个数组中，以减少内存使用： 123var array1 = [1, 2, 3]; var array2 = [4, 5, 6]; console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6]; 11) 把NodeList转换成数组如果运行document.querySelectorAll(&quot;p&quot;)函数，它会返回一个DOM元素数组，即NodeList对象。但是这个对象并没有一些属于数组的函数，例如：sort()，reduce()，map()，filter()。为了启用这些函数，以及数组的其他的原生函数，你需要将NodeList转换为数组。要进行转换，只需使用这个函数：[] .slice.call（elements）： 123var elements = document.querySelectorAll("p"); // NodeList var arrayElements = [].slice.call(elements); // 现在已经转换成数组了var arrayElements = Array.from(elements); // 把NodeList转换成数组的另外一个方法 12) 对数组元素进行洗牌如果要像外部库Lodash那样对数据元素重新洗牌，只需使用这个技巧： 1234var list = [1, 2, 3]; console.log(list.sort(function() &#123; return Math.random() - 0.5&#125;)); // [2,1,3]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL视图]]></title>
    <url>%2F2017%2F05%2F13%2F2017-05-13-mysqlView%2F</url>
    <content type="text"><![CDATA[概述： 视图即是虚拟表，也称为派生表，因为它们的内容都派生自其它表的查询结果。虽然视图看起来感觉和基本表一样，但是它们不是基本表。基本表的内容是持久的，而视图的内容是在使用过程中动态产生的。——摘自《SQLite权威指南》 基本使用:创建视图: 1CREATE VIEW "表名" AS "SQL 语句"; 优势： 1.可靠的安全性 2.查询性能提高 3.有效应对灵活性的功能需求 4.轻松应对复杂的查询需求 理解： 1.在使用视图的时候，就是与使用表的语法一样的。 2.创建视图的时候，该视图的名字如果与已经存在表重名的话，那么会报错，不允许创建。 3.视图就是一种特殊的表。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储过程]]></title>
    <url>%2F2017%2F05%2F10%2F2017-05-10-mysqlStoredProcedure%2F</url>
    <content type="text"><![CDATA[优缺点优点 在生产环境下，可以通过直接修改存储过程的方式修改业务逻辑（或bug），而不用重启服务器。但这一点便利被许多人滥用了。有人直接就在正式服务器上修改存储过程，而没有经过完整的测试，后果非常严重。 执行速度快。存储过程经过编译之后会比单独一条一条执行要快。但这个效率真是没太大影响。如果是要做大数据量的导入、同步，我们可以用其它手段。 减少网络传输。存储过程直接就在数据库服务器上跑，所有的数据访问都在服务器内部进行，不需要传输数据到其它终端。但我们的应付服务器通常与数据库是在同一内网，大数据的访问的瓶颈会是硬盘的速度，而不是网速。 能够解决presentation与数据之间的差异，说得文艺青年点就是解决OO模型与二维数据持久化之间的阻抗。领域模型和数据模型的设计可能不是同一个人（一个是SA，另一个是DBA），两者的分歧可能会很大——这不奇怪，一个是以OO的思想来设计，一个是结构化的数据来设计，大家互不妥协——你说为了软件的弹性必须这么设计，他说为了效率必须那样设计，为了抹平鸿沟，就用存储过程来做数据存储的逻辑映射（把属性映射到字段）。好吧，台下已经有同学在叨咕ORM了。 方便DBA优化。所有的SQL集中在一个地方，DBA会很高兴。这一点算是ORM的软肋。不过按照CQRS框架的思想，查询是用存储过程还是ORM，还真不是问题——DBA对数据库的优化，ORM一样会受益。况且放在ORM中还能用二级缓存，有些时候效率还会更高。 缺点 SQL本身是一种结构化查询语言，加上了一些控制（赋值、循环和异常处理等），但不是OO的，本质上还是过程化的，面对复杂的业务逻辑，过程化的处理会很吃力。这一点算致命伤。 不便于调试。基本上没有较好的调试器，很多时候是用print来调试，但用这种方法调试长达数百行的存储过程简直是噩梦。好吧，这一点不算啥，C#/Java一样能写出噩梦般的代码。 没办法应用缓存。虽然有全局临时表之类的方法可以做缓存，但同样加重了数据库的负担。如果缓存并发严重，经常要加锁，那效率实在堪忧。 无法适应数据库的切割（水平或垂直切割）。数据库切割之后，存储过程并不清楚数据存储在哪个数据库中. 基本语法一.创建存储过程1234create procedure sp_name()begin......end 二.调用存储过程 基本语法：call sp_name() 注意：存储过程名称后面必须加括号，哪怕该存储过程没有参数传递 三.删除存储过程 基本语法：drop procedure sp_name() 注意事项: 不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程 四.其他常用命令 show procedure status 显示数据库中所有存储的存储过程基本信息，包括所属数据库，存储过程名称，创建时间等 show create procedure sp_name 显示某一个MySQL存储过程的详细信息 数据类型及运算符一、基本数据类型二、变量：自定义变量：DECLARE a INT ; SET a=100; 可用以下语句代替：DECLARE a INT DEFAULT 100; 变量分为用户变量和系统变量，系统变量又分为会话和全局级变量 用户变量：用户变量名一般以@开头，滥用用户变量会导致程序难以理解及管理 1、 在mysql客户端使用用户变量 12345678mysql&gt; SELECT 'Hello World' into @x;mysql&gt; SELECT @x;mysql&gt; SET @y='Goodbye Cruel World';mysql&gt; select @y;mysql&gt; SET @z=1+2+3;mysql&gt; select @z; 2、 在存储过程中使用用户变量 123mysql&gt; CREATE PROCEDURE GreetWorld( ) SELECT CONCAT(@greeting,' World');mysql&gt; SET @greeting='Hello';mysql&gt; CALL GreetWorld( ); 3、 在存储过程间传递全局范围的用户变量 1234mysql&gt; CREATE PROCEDURE p1( ) SET @last_procedure='p1';mysql&gt; CREATE PROCEDURE p2( ) SELECT CONCAT('Last procedure was ',@last_procedure);mysql&gt; CALL p1( );mysql&gt; CALL p2( ); 三、运算符： 1.算术运算符 123456+ 加 SET var1=2+2; 4- 减 SET var2=3-2; 1* 乘 SET var3=3*2; 6/ 除 SET var4=10/3; 3.3333DIV 整除 SET var5=10 DIV 3; 3% 取模 SET var6=10%3 ; 1 2.比较运算符 123456789101112131415&gt; 大于 1&gt;2 False&lt; 小于 2&lt;1 False&lt;= 小于等于 2&lt;=2 True&gt;= 大于等于 3&gt;=2 TrueBETWEEN 在两值之间 5 BETWEEN 1 AND 10 TrueNOT BETWEEN 不在两值之间 5 NOT BETWEEN 1 AND 10 FalseIN 在集合中 5 IN (1,2,3,4) FalseNOT IN 不在集合中 5 NOT IN (1,2,3,4) True= 等于 2=3 False&lt;&gt;, != 不等于 2&lt;&gt;3 False&lt;=&gt; 严格比较两个NULL值是否相等 NULL&lt;=&gt;NULL TrueLIKE 简单模式匹配 &quot;Guy Harrison&quot; LIKE &quot;Guy%&quot; TrueREGEXP 正则式匹配 &quot;Guy Harrison&quot; REGEXP &quot;[Gg]reg&quot; FalseIS NULL 为空 0 IS NULL FalseIS NOT NULL 不为空 0 IS NOT NULL True 3.逻辑运算符 4.位运算符 12345| 或&amp; 与&lt;&lt; 左移位&gt;&gt; 右移位~ 非(单目运算，按位取反) 注释：/* 注释内容 */ 一般用于多行注释 流程控制一、顺序结构二、分支结构123if 条件 thenelse end if; 三、循环结构while循环 1234SET counter = 0; WHILE counter != 10 DO SET counter = counter+1; END WHILE; loop循环 1234567SET counter = 0; my_simple_loop: LOOP SET counter = counter+1; IF counter = 10 THEN LEAVE my_simple_loop; END IF; END LOOP my_simple_loop; repeat until循环 1234SET counter = 0; REPEAT SET counter = counter+1; UNTIL counter = 10 END REPEAT; 注：区块定义，常用 123begin......end; 也可以给区块起别名，如： 123lable:begin...........end lable; 可以用leave lable; 跳出区块，执行区块以后的代码 begin和end如同C语言中的{ 和 }。 输入和输出mysql存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT 1Create procedure|function([[IN |OUT |INOUT ] 参数名 数据类形...]) IN 输入参数 表示该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值 OUT 输出参数 该值可在存储过程内部被改变，并可返回 INOUT 输入输出参数 调用时指定，并且可被改变和返回 IN参数例子： 123456789101112CREATE PROCEDURE sp_demo_in_parameter(IN p_in INT)BEGINSELECT p_in; /*查询输入参数*/SET p_in=2; /*修改*/select p_in;/*查看修改后的值*/END;执行结果:mysql&gt; set @p_in=1mysql&gt; call sp_demo_in_parameter(@p_in)略mysql&gt; select @p_in;略 以上可以看出，p_in虽然在存储过程中被修改，但并不影响@p_id的值 OUT参数例子 123456789101112CREATE PROCEDURE sp_demo_out_parameter(out p_in INT)BEGINSELECT p_in;SET p_in=2; select p_in;END;执行结果:mysql&gt; set @p_in=1mysql&gt; call sp_demo_out_parameter(@p_in)略mysql&gt; select @p_in;略 INOUT参数例子： 123456789101112CREATE PROCEDURE sp_demo_inout_parameter(inout p_in INT)BEGINSELECT p_in;SET p_in=2; select p_in;END;执行结果:mysql&gt; set @p_in=1mysql&gt; call sp_demo_inout_parameter(@p_in)略mysql&gt; select @p_in;略 函数库mysql存储过程基本函数包括：字符串类型，数值类型，日期类型 一、字符串类12345678910111213141516171819202122232425262728293031323334353637CHARSET(str) //返回字串字符集CONCAT (string2 [,… ]) //连接字串INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0LCASE (string2 ) //转换成小写LEFT (string2 ,length ) //从string2中的左边起取length个字符LENGTH (string ) //string长度LOAD_FILE (file_name ) //从文件读取内容LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为lengthLTRIM (string2 ) //去除前端空格REPEAT (string2 ,count ) //重复count次REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_strRPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为lengthRTRIM (string2 ) //去除后端空格STRCMP (string1 ,string2 ) //逐字符比较两字串大小,SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1mysql&gt; select substring(’abcd’,0,2);+———————–+| substring(’abcd’,0,2) |+———————–+| |+———————–+1 row in set (0.00 sec)mysql&gt; select substring(’abcd’,1,2);+———————–+| substring(’abcd’,1,2) |+———————–+| ab |+———————–+1 row in set (0.02 sec)TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符UCASE (string2 ) //转换成大写RIGHT(string2,length) //取string2最后length个字符SPACE(count) //生成count个空格 二、数值类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546ABS (number2 ) //绝对值BIN (decimal_number ) //十进制转二进制CEILING (number2 ) //向上取整CONV(number2,from_base,to_base) //进制转换FLOOR (number2 ) //向下取整FORMAT (number,decimal_places ) //保留小数位数HEX (DecimalNumber ) //转十六进制注：HEX()中可传入字符串，则返回其ASC-11码，如HEX(’DEF’)返回4142143也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19LEAST (number , number2 [,..]) //求最小值MOD (numerator ,denominator ) //求余POWER (number ,power ) //求指数RAND([seed]) //随机数ROUND (number [,decimals ]) //四舍五入,decimals为小数位数]注：返回类型并非均为整数，如：(1)默认变为整形值mysql&gt; select round(1.23);+————-+| round(1.23) |+————-+| 1 |+————-+1 row in set (0.00 sec)mysql&gt; select round(1.56);+————-+| round(1.56) |+————-+| 2 |+————-+1 row in set (0.00 sec)(2)可以设定小数位数，返回浮点型数据mysql&gt; select round(1.567,2);+—————-+| round(1.567,2) |+—————-+| 1.57 |+—————-+1 row in set (0.00 sec)SIGN (number2 ) //返回符号,正负或0SQRT(number2) //开平方 三、日期类型12345678910111213141516171819202122232425262728293031ADDTIME (date2 ,time_interval ) //将time_interval加到date2CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区CURRENT_DATE ( ) //当前日期CURRENT_TIME ( ) //当前时间CURRENT_TIMESTAMP ( ) //当前时间戳DATE (datetime ) //返回datetime的日期部分DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetimeDATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间DATEDIFF (date1 ,date2 ) //两个日期差DAY (date ) //返回日期的天DAYNAME (date ) //英文星期DAYOFWEEK (date ) //星期(1-7) ,1为星期天DAYOFYEAR (date ) //一年中的第几天EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串MAKETIME (hour ,minute ,second ) //生成时间串MONTHNAME (date ) //英文月份名NOW ( ) //当前时间SEC_TO_TIME (seconds ) //秒数转成时间STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示TIMEDIFF (datetime1 ,datetime2 ) //两个时间差TIME_TO_SEC (time ) //时间转秒数]WEEK (date_time [,start_of_week ]) //第几周YEAR (datetime ) //年份DAYOFMONTH(datetime) //月的第几天HOUR(datetime) //小时LAST_DAY(date) //date的月的最后日期MICROSECOND(datetime) //微秒MONTH(datetime) //月MINUTE(datetime) //分 注：可用在INTERVAL中的类型：DAY ,DAY_HOUR ,DAY_MINUTE ,DAY_SECOND ,HOUR ,HOUR_MINUTE ,HOUR_SECOND ,MINUTE ,MINUTE_SECOND,MONTH ,SECOND ,YEAR1DECLARE variable_name [,variable_name...] datatype [DEFAULT value]; 其中，datatype为mysql的数据类型，如:INT, FLOAT, DATE, VARCHAR(length) 实例： 12345DECLARE l_int INT unsigned default 4000000;DECLARE l_numeric NUMERIC(8,2) DEFAULT 9.95;DECLARE l_date DATE DEFAULT '1999-12-31';DECLARE l_datetime DATETIME DEFAULT '1999-12-31 23:59:59';DECLARE l_varchar VARCHAR(255) DEFAULT 'This will not be padded';]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-空对象]]></title>
    <url>%2F2017%2F05%2F01%2F2017-05-01-nullObject%2F</url>
    <content type="text"><![CDATA[适用性 当程序运行过程中出现操作空对象时，程序依然能够通过操作提供的空对象继续执行 下面实现老师课堂叫学生回答问题 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 抽象类人 */abstract class Person&#123; /** * 名字 * @var string */ private $_name = ''; /** * 构造函数 */ function __construct($name) &#123; $this-&gt;_name = $name; &#125; /** * 魔术方法 * 读取私有属性 * * @param string $name 属性名称 * @return mixed */ function __get($name='') &#123; $name = '_' . $name; return $this-&gt;$name; &#125; /** * 抽象方法 * * @return mixed */ abstract function doSomthing($person);&#125;/** * 老师 */class Teacher extends Person&#123; /** * 老师提问 * * @return mixed */ function doSomthing($person) &#123; if (!$person instanceof Student) &#123; $person = new NullPerson(''); &#125; $person-&gt;doSomthing($this); &#125;&#125;/** * 学生 */class Student extends Person&#123; /** * 答题方法 * * @return mixed */ function doSomthing($person) &#123; echo "老师‘&#123;$person-&gt;name&#125;’让学生‘&#123;$this-&gt;name&#125;’回答了一道题~ \n"; &#125;&#125;/** * 鬼 */class NullPerson extends Person&#123; /** * 空方法 * * @return mixed */ function doSomthing($person) &#123; echo "难道这是个鬼吗............ \n"; &#125;&#125;try &#123; //创建一个老师：路飞 $teacher = new Teacher('路飞'); // 创建学生 $mc = new Student('麦迪'); $kobe = new Student('科比'); $paul = new Student('保罗'); // 老师提问 $teacher-&gt;doSomthing($mc); $teacher-&gt;doSomthing($kobe); $teacher-&gt;doSomthing($paul); $teacher-&gt;doSomthing('小李');// 提问了一个班级里不存在人名&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-中介者]]></title>
    <url>%2F2017%2F04%2F27%2F2017-04-27-mediator%2F</url>
    <content type="text"><![CDATA[适用性 就是不同的对象之间通信，互相之间不直接调用，而是通过一个中间对象（中介者） 使用场景：对象之间大量的互相依赖 下面实现一个房屋中介 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** * 抽象类人 */abstract class Person&#123; /** * 名字 * @var string */ private $_name = ''; /** * 构造函数 */ function __construct($name) &#123; $this-&gt;_name = $name; &#125; /** * 魔术方法 * 读取私有属性 * * @param string $name 属性名称 * @return mixed */ function __get($name='') &#123; $name = '_' . $name; return $this-&gt;$name; &#125; /** * 抽象方法 * * @return mixed */ abstract function doSomthing(Person $person);&#125;/** * 房屋中介 */class HouseMediator&#123; /** * 提供租房服务 * * @param Person $person 租客 * @return Person */ function rentHouse(Person $person) &#123; // 初始化一个房东 $landlord = new Landlord('小梅'); // 租房子 echo '通过房屋中介，' . $landlord-&gt;doSomthing($person); &#125;&#125;/** * 房东 */class Landlord extends Person&#123; /** * 租出去房子 * * @return mixed */ public function doSomthing(Person $person) &#123; // 租出去闲置房子 return "‘&#123;$this-&gt;name&#125;’租出去一件闲置房给‘&#123;$person-&gt;name&#125;’ ～ \n"; &#125;&#125;/** * 租客 */class Tenant extends Person&#123; /** * 组间房子 * * @return mixed */ public function doSomthing(Person $person) &#123; // 本来是之间找房东租房,但是茫茫人海错综复杂 // 下面我们通过一家正规的房屋中介租房 $houseMediator = new HouseMediator(); $houseMediator-&gt;rentHouse($this); &#125;&#125;try &#123; // 初始化一个租客 $tenant = new Tenant('小明'); // 小明直接找小梅租房 $landlord = new Landlord('小梅'); echo $landlord-&gt;doSomthing($tenant); // 小明通过房屋中介租房 // 初始化一个房屋中介 $mediator = new HouseMediator(); // 租房 $mediator-&gt;rentHouse($tenant);&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-迭代器]]></title>
    <url>%2F2017%2F04%2F26%2F2017-04-26-iterator%2F</url>
    <content type="text"><![CDATA[适用性 遍历对象内部的属性，无需对外暴露内部的构成 下面我们来实现一个迭代器访问学校所有的老师 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196namespace iterator;/** * 学校接口 */interface School&#123; /** * 获取迭代器 * * @return mixed */ public function getIterator();&#125;/** * 迭代器接口 */interface Iterator&#123; /** * 是否还有下一个 * * @return boolean */ public function hasNext(); /** * 下一个 * * @return object */ public function next(); /** * 当前 * * @return mixed */ public function current(); /** * 当前索引 * * @return mixed */ public function index();&#125;/** * 实验小学实体 */class SchoolExperimental implements School&#123; /** * 老师集合 * @var */ private $_teachers = []; /** * 魔法方法 * * @param string $name 属性名称 * @return mixed */ public function __get($name='') &#123; $name = '_' . $name; return $this-&gt;$name; &#125; /** * 添加老师 * @param string $name */ public function addTeacher($name='') &#123; $this-&gt;_teachers[] = $name; &#125; /** * 获取教师迭代器 * * @return mixed */ public function getIterator() &#123; return new TeacherIterator($this); &#125;&#125;/** * 老师迭代实体 */class TeacherIterator implements Iterator&#123; /** * 索引值 * @var integer */ private $_index = 0; /** * 要迭代的对象 * @var object */ private $_teachers; /** * 构造函数 * * @param School $school */ public function __construct(School $school) &#123; $this-&gt;_teachers = $school-&gt;teachers; &#125; /** * 是否还有下一个 * * @return boolean */ public function hasNext() &#123; if ($this-&gt;_index &lt; count($this-&gt;_teachers)) &#123; return true; &#125; return false; &#125; /** * 下一个 * * @return object */ public function next() &#123; if (!$this-&gt;hasNext()) &#123; echo NULL; return; &#125; $index = $this-&gt;_index + 1; echo $this-&gt;_teachers[$index]; &#125; /** * 当前 * * @return mixed */ public function current() &#123; if (!isset($this-&gt;_teachers[$this-&gt;_index])) &#123; echo NULL; return; &#125; $current = $this-&gt;_teachers[$this-&gt;_index]; $this-&gt;_index += 1; echo $current . "\n"; &#125; /** * 当前索引 * * @return integer */ public function index() &#123; echo $this-&gt;_index; &#125;&#125;try &#123; // 初始化一个实验小学 $experimental = new SchoolExperimental(); // 添加老师 $experimental-&gt;addTeacher('Griffin'); $experimental-&gt;addTeacher('Curry'); $experimental-&gt;addTeacher('Mc'); $experimental-&gt;addTeacher('Kobe'); $experimental-&gt;addTeacher('Rose'); $experimental-&gt;addTeacher('Kd'); // 获取教师迭代器 $iterator = $experimental-&gt;getIterator(); // 打印所有老师 do &#123; $iterator-&gt;current(); &#125; while ($iterator-&gt;hasNext());&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-命令]]></title>
    <url>%2F2017%2F04%2F25%2F2017-04-25-command%2F</url>
    <content type="text"><![CDATA[适用性 命令模式:就是在依赖的类中间加一个命令类，本来可以直接调用的类方法现在通过命令来调用，已达到 解耦的的目的，其次可以实现undo，redo等操作，因为你知道调了哪些命令 下面我们来用命令模式实现一个记事本，涉及的命令： 新建 写入 保存 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248/** * 命令接口 */interface Order&#123; /** * 执行命令 * @return void */ public function execute();&#125;/** * 文本类 */class Text&#123; /** * 创建 * * @param string $name 文件名称 * @return string */ public function create($filename='') &#123; echo "创建了一个文件: &#123;$filename&#125; \n"; &#125; /** * 写入 * * @param string $content 文件名称 * @return string */ public function write($filename='', $content='') &#123; echo "文件&#123;$filename&#125;写入了内容: &#123;$content&#125; \n"; &#125; /** * 保存 * * @param string $filename 文件名称 * @return string */ public function save($filename='') &#123; echo "保存了一个文件: &#123;$filename&#125; \n"; &#125;&#125;/** * 控制台 * 负责命令执行 */class Console&#123; /** * 命令队列 * @var array */ private $_orderList = []; /** * 添加命令到队列 * @param Order $order */ public function add(Order $order) &#123; array_push($this-&gt;_orderList, $order); &#125; /** * 执行命令 * @return mixed */ public function run() &#123; foreach ($this-&gt;_orderList as $k =&gt; $v) &#123; $v-&gt;execute(); &#125; &#125;&#125;/** * 创建文本命令 */class OrderCreate implements Order&#123; /** * 文本类实体 * @var object */ private $_text; /** * 命令参数 * @var array */ private $_arguments = [ 'filename' =&gt; '' ]; /** * 构造函数 * * @param Text $text * @param array $arguments */ public function __construct(Text $text, $arguments=[]) &#123; $this-&gt;_text = $text; $this-&gt;_arguments = $arguments; &#125; /** * 执行命令 * * @return void */ public function execute() &#123; $this-&gt;_text-&gt;create($this-&gt;_arguments['filename']); &#125;&#125;/** * 保存文本命令 */class OrderSave implements Order&#123; /** * 文本类实体 * @var object */ private $_text; /** * 命令参数 * @var array */ private $_arguments = [ 'filename' =&gt; '' ]; /** * 构造函数 * * @param Text text * @param array $arguments */ public function __construct(Text $text, $arguments=[]) &#123; $this-&gt;_text = $text; $this-&gt;_arguments = $arguments; &#125; /** * 执行命令 * * @return void */ public function execute() &#123; $this-&gt;_text-&gt;save($this-&gt;_arguments['filename']); &#125;&#125;/** * 写入文本命令 */class OrderWrite implements Order&#123; /** * 文本类实体 * @var object */ private $_text; /** * 命令参数 * @var array */ private $_arguments = [ 'filename' =&gt; '', 'content' =&gt; '' ]; /** * 构造函数 * * @param Text text * @param array $arguments */ public function __construct(Text $text, $arguments=[]) &#123; $this-&gt;_text = $text; $this-&gt;_arguments = $arguments; &#125; /** * 执行命令 * * @return void */ public function execute() &#123; $this-&gt;_text-&gt;Write( $this-&gt;_arguments['filename'], $this-&gt;_arguments['content'] ); &#125;&#125;try &#123; // 创建一个记事本实例 $text = new Text(); // 创建命令 $create = new OrderCreate($text, [ 'filename' =&gt; 'test.txt' ]); // 写入命令 $write = new OrderWrite($text, [ 'filename' =&gt; 'test.txt', 'content' =&gt; 'life is a struggle' ]); // 保存命令 $save = new OrderSave($text, [ 'filename' =&gt; 'text.txt' ]); // 创建一个控制台 $console = new Console(); // 添加命令 $console-&gt;add($create); $console-&gt;add($write); $console-&gt;add($save); // 运行命令 $console-&gt;run();&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-备忘录]]></title>
    <url>%2F2017%2F04%2F23%2F2017-04-23-memento%2F</url>
    <content type="text"><![CDATA[适用性 就是外部存储对象的状态，以提供后退/恢复/复原 使用场景：编辑器后退操作/数据库事物/存档 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159class Memento&#123; /** * 备忘录列表 * * @var array */ private $_mementoList = []; /** * 添加编辑器实例状态 * * @param Editor $editor 编辑器实例 */ function add(Editor $editor) &#123; array_push($this-&gt;_mementoList, $editor); &#125; /** * 返回编辑器实例上个状态 * * @param Editor $editor 编辑器实例 */ function undo() &#123; return array_pop($this-&gt;_mementoList); &#125; /** * 返回编辑器实例开始状态 * * @param Editor $editor 编辑器实例 */ function redo() &#123; return array_shift($this-&gt;_mementoList); &#125;&#125;class Editor&#123; /** * 编辑器内容 * @var string */ private $_content = ''; /** * 备忘录实例 * @var Memento */ private $_memento; /** * 构造函数 * * @param string $content 打开的文件内容 */ function __construct($content='') &#123; $this-&gt;_content = $content; // 打印初始内容 $this-&gt;read(); // 初始化备忘录插件 $this-&gt;_memento = new Memento(); // 第一次打开编辑器自动保存一次以提供重置状态操作 $this-&gt;save($content); &#125; /** * 写入内容 * * @param string $value 文本 * @return boolean */ function write($value='') &#123; $this-&gt;_content .= $value; $this-&gt;read(); &#125; /** * 读取当前内容 * * @param string $value 文本 * @return boolean */ function read() &#123; echo $this-&gt;_content? $this-&gt;_content . "\n": "空文本" . "\n"; &#125; /** * 保存内容 * * @return boolean */ function save() &#123; $this-&gt;_memento-&gt;add(clone $this); &#125; /**s * 后退 * * @return boolean */ function undo() &#123; // 获取上个状态 $undo = $this-&gt;_memento-&gt;undo(); // 重置当前状态为上个状态 $this-&gt;_content = $undo-&gt;_content; &#125; /** * 复原 * * @return boolean */ function redo() &#123; // 获取开始状态 $undo = $this-&gt;_memento-&gt;redo(); // 重置当前状态为开始状态 $this-&gt;_content = $undo-&gt;_content; &#125;&#125;try &#123; // 初始化一个编辑器并新建一个空文件 $editor = new Editor(''); // 写入一段文本 $editor-&gt;write('hello php !'); // 保存 $editor-&gt;save(); // 修改刚才的文本 $editor-&gt;write(' no code no life !'); // 撤销 $editor-&gt;undo(); $editor-&gt;read(); // 再次修改并保存文本 $editor-&gt;write(' life is a struggle !'); $editor-&gt;save(); // 重置 $editor-&gt;redo(); $editor-&gt;read();&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-解释器]]></title>
    <url>%2F2017%2F04%2F20%2F2017-04-20-interpreter%2F</url>
    <content type="text"><![CDATA[适用性 理解：就是一个上下文的连接器 使用场景：构建一个编译器，SQL解析器 下面我们来实现一个简单增删改查的sql解析器 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215class SqlInterpreter&#123; /** * 表名 * @var string */ private $_tableName = ''; /** * 当前类的实例 * @var object */ private static $_instance; /** * 设置表名 * * @param string $table 表名 */ public static function db($tableName='') &#123; if (empty($tableName)) &#123; throw new Exception("argument tableName is null", 400); &#125; // 单例 if(!self::$_instance instanceof self)&#123;// instanceof运算符的优先级高于！ self::$_instance = new self(); &#125; // 更新实例表名 self::$_instance-&gt;_setTableName($tableName); // 返回实例 return self::$_instance; &#125; /** * 设置表名 * * @param string $tableName 表名 */ private function _setTableName($tableName='') &#123; $this-&gt;_tableName = $tableName; &#125; /** * 插入一条数据 * * @param array $data 数据 * @return mixed */ public function insert($data=[]) &#123; if (empty($data)) &#123; throw new Exception("argument data is null", 400); &#125; $count = count($data); //拼接字段 $field = array_keys($data); $fieldString = ''; foreach ($field as $k =&gt; $v) &#123; if ($k === (int)($count - 1)) &#123; $fieldString .= "`&#123;$v&#125;`"; continue; &#125; $fieldString .= "`&#123;$v&#125;`".','; &#125; unset($k); unset($v); //拼接值 $value = array_values($data); $valueString = ''; foreach ($value as $k =&gt; $v) &#123; if ($k === (int)($count - 1)) &#123; $valueString .= "'&#123;$v&#125;'"; continue; &#125; $valueString .= "'&#123;$v&#125;'".','; &#125; unset($k); unset($v); $sql = "INSERT INTO `&#123;$this-&gt;_tableName&#125;` (&#123;$fieldString&#125;) VALUES (&#123;$valueString&#125;)"; echo $sql . "\n"; &#125; /** * 删除数据 * * @param array $data 数据 * @return mixed */ public function delete($data=[]) &#123; if (empty($data)) &#123; throw new Exception("argument data is null", 400); &#125; // 拼接where语句 $count = (int)count($data); $where = ''; $dataCopy = $data; $pop = array_pop($dataCopy); if ($count === 1) &#123; $field = array_keys($data)[0]; $value = array_values($data)[0]; $where = "`&#123;$field&#125;` = '&#123;$value&#125;'"; &#125;else&#123; foreach ($data as $k =&gt; $v) &#123; if ($v === $pop) &#123; $where .= "`&#123;$k&#125;` = '&#123;$v&#125;'"; continue; &#125; $where .= "`&#123;$k&#125;` = '&#123;$v&#125;' AND "; &#125; &#125; $sql = "DELETE FROM `&#123;$this-&gt;_tableName&#125;` WHERE &#123;$where&#125;"; echo $sql . "\n"; &#125; /** * 更新一条数据 * * @param array $data 数据 * @return mixed */ public function update($data=[]) &#123; if (empty($data)) &#123; throw new Exception("argument data is null", 400); &#125; if (empty($data['id'])) &#123; throw new Exception("argument data['id'] is null", 400); &#125; $set = ''; $dataCopy = $data; $pop = array_pop($dataCopy); foreach ($data as $k =&gt; $v) &#123; if ($v === $pop) &#123; $set .= "`&#123;$k&#125;` = '$v'"; continue; &#125; $set .= "`&#123;$k&#125;` = '$v',"; &#125; $sql = "UPDATE `&#123;$this-&gt;_tableName&#125;` SET &#123;$set&#125;"; echo $sql . "\n"; &#125; /** * 查找一条数据 * * @param array $data 数据 * @return mixed */ public function find($data=[]) &#123; if (empty($data)) &#123; throw new Exception("argument data is null", 400); &#125; // 拼接where语句 $count = (int)count($data); $where = ''; $dataCopy = $data; $pop = array_pop($dataCopy); if ($count === 1) &#123; $field = array_keys($data)[0]; $value = array_values($data)[0]; $where = "`&#123;$field&#125;` = '&#123;$value&#125;'"; &#125;else&#123; foreach ($data as $k =&gt; $v) &#123; if ($v === $pop) &#123; $where .= "`&#123;$k&#125;` = '&#123;$v&#125;'"; continue; &#125; $where .= "`&#123;$k&#125;` = '&#123;$v&#125;' AND "; &#125; &#125; $sql = "SELECT * FROM `&#123;$this-&gt;_tableName&#125;` WHERE &#123;$where&#125;"; echo $sql . "\n"; &#125;&#125;try &#123; //增加数据 SqlInterpreter::db('user')-&gt;insert([ 'nickname' =&gt; 'tigerb', 'mobile' =&gt; '1366666666', 'password' =&gt; '123456' ]); //删除数据 SqlInterpreter::db('user')-&gt;delete([ 'nickname' =&gt; 'tigerb', 'mobile' =&gt; '1366666666', ]); //修改数据 SqlInterpreter::db('member')-&gt;update([ 'id' =&gt; '1', 'nickname' =&gt; 'tigerbcode' ]); //查询数据 SqlInterpreter::db('member')-&gt;find([ 'mobile' =&gt; '1366666666', ]);&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-访问者]]></title>
    <url>%2F2017%2F04%2F09%2F2017-04-09-visitor%2F</url>
    <content type="text"><![CDATA[适用性 说说我对的策略模式和访问者模式的区分： 乍一看，其实两者都挺像的，都是实体类依赖了外部实体的算法，但是： 对于策略模式：首先你是有一堆算法，然后在不同的逻辑中去使用 对于访问者模式：实体的【结构是稳定的】，但是结构中元素的算法却是多变的，比如就像人吃饭这个动作 是稳定不变的，但是具体吃的行为却又是多变的 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 动物接口 */interface AnimailInterface&#123; /** * 行为吃 * * @param VisitorInterface $visitor 访问者 * @return void */ public function eat(VisitorInterface $visitor);&#125;/** * 实体人 * * 人吃饭的行为是不变的,但是吃什么是依照环境而定的 */class Person implements AnimailInterface&#123; /** * 行为吃 * 具体吃什么依照访问者而定 * * @param VisitorInterface $visitor 访问者 * @return void */ public function eat(VisitorInterface $visitor) &#123; $visitor-&gt;eat(); &#125;&#125;/** * 访问者接口 */interface VisitorInterface&#123; /** * 行为吃 * * @return void */ public function eat();&#125;/** * 访问者实体 * * 亚洲 */class VisitorAsia implements VisitorInterface&#123; /** * 行为吃 * * @return void */ public function eat() &#123; echo "身处亚洲，所以主要吃大米咯~ \n"; &#125;&#125;/** * 访问者实体 * * 美洲 */class VisitorAmerica implements VisitorInterface&#123; /** * 行为吃 * * @return void */ public function eat() &#123; echo "身处美洲，所以主要吃油炸食物咯~ \n"; &#125;&#125;// 生产一个人的实例$person = new Person();// 来到了亚洲$person-&gt;eat(new VisitorAsia());// 来到了美洲$person-&gt;eat(new VisitorAmerica());]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-责任链]]></title>
    <url>%2F2017%2F04%2F06%2F2017-04-06-chainOfResponsibility%2F</url>
    <content type="text"><![CDATA[适用性 把一个对象传递到一个对象链上，直到有对象处理这个对象 可以干什么：我们可以做一个filter,或者gateway 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189/** * 请求对象 */class Request&#123; /** * 请求对象身份标识 * @var string */ private $_requestId = ''; /** * 魔术方法 设置私有属性 * @param string $name 属性名称 * @param string $value 属性值 */ public function __set($name='', $value='') &#123; $name = '_' . $name; $this-&gt;$name = $value; &#125; /** * 魔术方法 获取私有属性 * @param string $name 属性名称 */ public function __get($name='') &#123; $name = '_' . $name; return $this-&gt;$name; &#125;&#125;/** * handler抽象类 */abstract class Handler&#123; /** * 下一个hanler对象 * @var [type] */ private $_nextHandler; /** * 校验方法 * * @param Request $request 请求对象 */ abstract public function Check(Request $request); /** * 设置责任链上的下一个对象 * * @param Handler $handler */ public function setNext(Handler $handler) &#123; $this-&gt;_nextHandler = $handler; return $handler; &#125; /** * 启动 * * @param Handler $handler */ public function start(Request $request) &#123; $this-&gt;check($request); // 调用下一个对象 if (!empty($this-&gt;_nextHandler)) &#123; $this-&gt;_nextHandler-&gt;start($request); &#125; &#125;&#125;/** * handler接口 **/class HandlerAccessToken extends Handler&#123; /** * 校验方法 * * @param Request $request 请求对象 */ public function Check(Request $request) &#123; echo "请求&#123;$request-&gt;requestId&#125;: 令牌校验通过～ \n"; &#125;&#125;/** * handler接口 */class HandlerArguments extends Handler&#123; /** * 校验方法 * * @param Request $request 请求对象 */ public function Check(Request $request) &#123; echo "请求&#123;$request-&gt;requestId&#125;: 参数校验通过～ \n"; &#125;&#125;/** * handler接口 */class HandlerAuthority extends Handler&#123; /** * 校验方法 * * @param Request $request 请求对象 */ public function Check(Request $request) &#123; echo "请求&#123;$request-&gt;requestId&#125;: 权限校验通过～ \n"; &#125;&#125;/** * handler接口 */class HandlerFrequent extends Handler&#123; /** * 校验方法 * * @param Request $request 请求对象 */ public function Check(Request $request) &#123; echo "请求&#123;$request-&gt;requestId&#125;: 请求频率校验通过～ \n"; &#125;&#125;/** * handler接口 */class HandlerSign extends Handler&#123; /** * 校验方法 * * @param Request $request 请求对象 */ public function Check(Request $request) &#123; echo "请求&#123;$request-&gt;requestId&#125;: 签名校验通过～ \n"; &#125;&#125;try &#123; // 下面我们用责任链模式实现一个api-gateway即接口网关 // 初始化一个请求对象 $request = new Request(); // 设置一个请求身份id $request-&gt;requestId = uniqid(); // 初始化一个：令牌校验的handler $handlerAccessToken = new HandlerAccessToken(); // 初始化一个：访问频次校验的handler $handlerFrequent = new HandlerFrequent(); // 初始化一个：必传参数校验的handler $handlerArguments = new HandlerArguments(); // 初始化一个：签名校验的handler $handlerSign = new HandlerSign(); // 初始化一个：访问权限校验的handler $handlerAuthority = new HandlerAuthority(); // 构成对象链 $handlerAccessToken-&gt;setNext($handlerFrequent) -&gt;setNext($handlerArguments) -&gt;setNext($handlerSign) -&gt;setNext($handlerAuthority); // 启动网关 $handlerAccessToken-&gt;start($request);&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-观察者]]></title>
    <url>%2F2017%2F04%2F05%2F2017-04-05-observer%2F</url>
    <content type="text"><![CDATA[适用性 观察者观察被观察者，被观察者通知观察者 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 观察者接口 */interface ObserverInterface&#123; /** * 行为 * @return void */ public function doSomething(ObservableInterface $observable);&#125;/** * 观察者实体类示例1 */class ObserverExampleOne implements ObserverInterface&#123; /** * 行为 * @return mixed */ public function doSomething(ObservableInterface $observable) &#123; echo $observable-&gt;_name . "通知了观察者1 \n"; &#125;&#125;/** * 观察者实体类示例2 */class ObserverExampleTwo implements ObserverInterface&#123; /** * 行为 * @return mixed */ public function doSomething(ObservableInterface $observable) &#123; echo $observable-&gt;_name . "通知了观察者2 \n"; &#125;&#125;/** * 被观察者接口 * * 需要实现附加观察者，删除观察者，通知观察者方法 */interface ObservableInterface&#123; /** * 附加观察者 * @return void */ public function attach(ObserverInterface $observer); /** * 解除观察者 * @return void */ public function detach(ObserverInterface $observer); /** * 通知观察者 * @return void */ public function notify();&#125;/** * 被观察者实体类 * * 实现附加观察者，删除观察者，通知观察者方法 */class Observable implements ObservableInterface&#123; /** * 观察者们 * @var array */ private $_observers = []; /** * 被观察者名称 * @var string */ private $_name = '【被观察者:皮皮虾】'; /** * 魔术方法 __get * @param string $name 属性名称 * @return mixed */ public function __get($name='') &#123; return $this-&gt;$name; &#125; /** * 附加观察者 * @return void */ public function attach(ObserverInterface $observer) &#123; if (!in_array($observer, $this-&gt;_observers, true)) &#123; $this-&gt;_observers[] = $observer; &#125; &#125; /** * 解除观察者 * @return void */ public function detach(ObserverInterface $observer) &#123; foreach ($this-&gt;_observers as $k =&gt; $v) &#123; if ($v === $observer) &#123; unset($this-&gt;_observers[$k]); &#125; &#125; &#125; /** * 通知观察者 * @return void */ public function notify() &#123; foreach ($this-&gt;_observers as $v) &#123; $v-&gt;doSomething($this); &#125; &#125;&#125;// 注册一个被观察者对象$observable = new Observable();// 注册观察者们$observerExampleOne = new ObserverExampleOne();$observerExampleTwo = new ObserverExampleTwo();// 附加观察者$observable-&gt;attach($observerExampleOne);$observable-&gt;attach($observerExampleTwo);// 被观察者通知观察者们$observable-&gt;notify();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-状态]]></title>
    <url>%2F2017%2F04%2F04%2F2017-04-04-state%2F</url>
    <content type="text"><![CDATA[适用性 理解：行为随着状态变化 区别： 策略的改变由client完成，client持有context的引用；而状态的改变是由context或状态自己, 就是自身持有context 简单说就是策略是client持有context，而状态是本身持有context 使用场景：大量和对象状态相关的条件语句 下面我们来实现一个农民四季种菜 春季：玉米 夏季：黄瓜 秋季：白菜 冬季：菠菜 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270/** * 农耕接口 */interface Farm&#123; /** * 种植 * * @return string */ function grow(); /** * 收割 * * @return string */ function harvest();&#125;/** * 农耕接口 */class FarmAutumn implements Farm&#123; /** * 作物名称 * @var string */ private $_name = '白菜'; /** * 种植 * * @return string */ function grow() &#123; echo "种植了一片 &#123;$this-&gt;_name&#125; \n"; &#125; /** * 收割 * * @return string */ function harvest() &#123; echo "收获了一片 &#123;$this-&gt;_name&#125; \n"; &#125;&#125;/** * 农耕接口 */class FarmSpring implements Farm&#123; /** * 作物名称 * @var string */ private $_name = '玉米'; /** * 种植 * * @return string */ function grow() &#123; echo "种植了一片 &#123;$this-&gt;_name&#125; \n"; &#125; /** * 收割 * * @return string */ function harvest() &#123; echo "收获了一片 &#123;$this-&gt;_name&#125; \n"; &#125;&#125;/** * 农耕接口 */class FarmSummer implements Farm&#123; /** * 作物名称 * @var string */ private $_name = '黄瓜'; /** * 种植 * * @return string */ function grow() &#123; echo "种植了一片 &#123;$this-&gt;_name&#125; \n"; &#125; /** * 收割 * * @return string */ function harvest() &#123; echo "收获了一片 &#123;$this-&gt;_name&#125; \n"; &#125;&#125;/** * 农耕接口 */class FarmWinter implements Farm&#123; /** * 作物名称 * @var string */ private $_name = '菠菜'; /** * 种植 * * @return string */ function grow() &#123; echo "种植了一片 &#123;$this-&gt;_name&#125; \n"; &#125; /** * 收割 * * @return string */ function harvest() &#123; echo "收获了一片 &#123;$this-&gt;_name&#125; \n"; &#125;&#125;/** * 农民类 */class Farmer&#123; /** * 当前季节 * * @var string */ private $_currentSeason = ''; /** * 季节 * @var string */ private $_season = [ 'spring', 'summer', 'autumn', 'winter' ]; /** * 状态 * @var object */ private $_state; /** * 设置状态 * @param Farm $farm 种植方法 */ private function setState($currentSeason) &#123; if ($currentSeason === 'spring') &#123; $this-&gt;_state = new FarmSpring(); &#125; if ($currentSeason === 'summer') &#123; $this-&gt;_state = new FarmSummer(); &#125; if ($currentSeason === 'autumn') &#123; $this-&gt;_state = new FarmAutumn(); &#125; if ($currentSeason === 'winter') &#123; $this-&gt;_state = new FarmWinter(); &#125; &#125; /** * 设置下个季节状态 */ private function nextSeason() &#123; $nowKey = (int)array_search($this-&gt;_currentSeason, $this-&gt;_season); if ($nowKey &lt; 3) &#123; $nextSeason = $this-&gt;_season[$nowKey+1]; &#125;else&#123; $nextSeason = 'spring'; &#125; $this-&gt;_currentSeason = $nextSeason; $this-&gt;setState($this-&gt;_currentSeason); &#125; /** * 设置初始状态 */ function __construct($season = 'spring') &#123; $this-&gt;_currentSeason = $season; $this-&gt;setState($this-&gt;_currentSeason); &#125; /** * 种植 * * @return string */ function grow() &#123; $this-&gt;_state-&gt;grow(); &#125; /** * 收割 * * @return string */ function harvest() &#123; $this-&gt;_state-&gt;harvest(); // 设置下一个季节状态 $this-&gt;nextSeason(); &#125;&#125;try &#123; // 初始化一个农民 $farmer = new Farmer(); // 春季 $farmer-&gt;grow(); $farmer-&gt;harvest(); // 夏季 $farmer-&gt;grow(); $farmer-&gt;harvest(); // 秋季 $farmer-&gt;grow(); $farmer-&gt;harvest(); // 冬季 $farmer-&gt;grow(); $farmer-&gt;harvest();&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-策略]]></title>
    <url>%2F2017%2F03%2F31%2F2017-03-31-strategy%2F</url>
    <content type="text"><![CDATA[适用性 策略依照使用而定 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 观察者接口 */interface StrategyInterface&#123; /** * 行为 * @return void */ public function doSomething();&#125;/** * 观察者实体类示例1 */class StrategyExampleOne implements StrategyInterface&#123; /** * 行为 * @return mixed */ public function doSomething() &#123; echo "你选择了策略1 \n"; &#125;&#125;/** * 观察者实体类示例2 */class StrategyExampleTwo implements StrategyInterface&#123; /** * 行为 * @return mixed */ public function doSomething() &#123; echo "你选择了策略2 \n"; &#125;&#125;/** * 实体类 * * 依赖外部不同策略的实体类 */class Substance&#123; /** * 策略实例 * @var object */ private $_strategy; /** * 构造函数 * 初始化策略 * * @param Strategy $strategy 策略实例 */ public function __construct(StrategyInterface $strategy) &#123; $this-&gt;_strategy = $strategy; &#125; /** * 模拟一个操作 * * @return mixed */ public function someOperation() &#123; $this-&gt;_strategy-&gt;doSomething(); &#125;&#125;// 使用策略1$substanceOne = new Substance(new StrategyExampleOne);$substanceOne-&gt;someOperation();// 使用策略2$substanceTwo = new Substance(new StrategyExampleTwo);$substanceTwo-&gt;someOperation();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-模板]]></title>
    <url>%2F2017%2F03%2F30%2F2017-03-30-template%2F</url>
    <content type="text"><![CDATA[适用性 理解：典型的控制反转，子类复写算法，但是最终的调用都是抽象类中定义的方式，也就是说抽象类中 定义了算法的执行顺序 使用场景：例如短信系统，选择不同的短信商，但是发送短信的动作都是一样的,未来要增加不同的厂商 只需添加子类即可 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/** * 短信抽象类 * * 定义算法结构 * 明确算法执行顺序 */abstract class Sms&#123; /** * 运营商配置 * @var string */ protected $_config = []; /** * 短信文本 * @var string */ protected $_text = '[xx公司]你好，你的验证码是'; /** * 构造函数 * * @param array $config 运营商配置 */ final function __construct($config=[]) &#123; // 初始化配置 $this-&gt;initialize($config); &#125; /** * 初始化运营商配置 * * 每个厂商的配置不一定相同，所以子类复写这个方法即可 * * @param array $config 运营商配置 * @return void */ abstract function initialize($config=[]); /** * 生成短信文本 * * 短信模板和厂商无关 * * @return void */ function makeText() &#123; $this-&gt;_text .= rand(000000, 999999); &#125; /** * 厂商发送短信方法 * * 每个厂商复写这个方法即可 * * @param integer $mobile 手机号 * @return void */ abstract function sendSms($mobile=0); /** * 发送短信 * * 最终调用的方法，明确了算法顺序 * * @param integer $mobile 手机号 * @return void */ final function send($mobile=0) &#123; // 生成文本 $this-&gt;makeText(); // 发送短信 $this-&gt;sendSms($mobile); &#125;&#125;/** * 某厂商one */class SmsCompanyOne extends Sms&#123; /** * 初始化运营商配置 * * 每个厂商的配置不一定相同，所以子类复写这个方法即可 * * @param array $config 运营商配置 * @return void */ function initialize($config=[]) &#123; // 实现具体算法 $this-&gt;_config = $config; &#125; /** * 厂商发送短信方法 * * 每个厂商复写这个方法即可 * * @param integer $mobile 手机号 * @return void */ function sendSms($mobile=0) &#123; // 实现具体的短信发送方法 echo "厂商‘one’给手机号&#123;$mobile&#125;发送了短信：&#123;$this-&gt;_text&#125; \n"; &#125;&#125;/** * 某厂商two */class SmsCompanyTwo extends Sms&#123; /** * 初始化运营商配置 * * 每个厂商的配置不一定相同，所以子类复写这个方法即可 * * @param array $config 运营商配置 * @return void */ function initialize($config=[]) &#123; // 实现具体算法 $this-&gt;_config = $config; &#125; /** * 厂商发送短信方法 * * 每个厂商复写这个方法即可 * * @param integer $mobile 手机号 * @return void */ function sendSms($mobile=0) &#123; // 实现具体的短信发送方法 echo "厂商‘two’给手机号&#123;$mobile&#125;发送了短信：&#123;$this-&gt;_text&#125; \n"; &#125;&#125;try &#123; // 用厂商one发短信 $one = new SmsCompanyOne([ 'appkey' =&gt; 'akjlooolllnn', ]); $one-&gt;send('13666666666'); // 用厂商two发短息 $one = new SmsCompanyTwo([ 'pwd' =&gt; 'adadeooonn', ]); $one-&gt;send('13666666666');&#125; catch (\Exception $e) &#123; echo 'error:' . $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-过滤器]]></title>
    <url>%2F2017%2F03%2F29%2F2017-03-29-filter%2F</url>
    <content type="text"><![CDATA[适用性 允许我们使用不同的规则过滤某一组对象 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153/** * 过滤接口 */interface FilterInterface&#123; /** * 过滤方法 * * @param SportsMan $person 运动员 * @return mixed */ public function filter(array $person);&#125;/** * 按运动项目过滤实体 */class SportsPerson&#123; /** * 性别 * @var string */ private $_gender = ''; /** * 按照本运动项目过滤 * @var string */ private $_sportType = ''; /** * 构造函数 * @param string $gender * @param string $sportType */ public function __construct($gender='', $sportType='') &#123; $this-&gt;_gender = $gender; $this-&gt;_sportType = $sportType; &#125; /** * 魔法函数 * @param string $value * @return mixed */ public function __get($value='') &#123; $value = '_' . $value; return $this-&gt;$value; &#125;&#125;/** * 按性别过滤实体 */class FilterGender implements FilterInterface&#123; /** * 按照本性别过滤 * @var string */ private $_gender = ''; /** * 构造函数 * @param string $gender */ public function __construct($gender='') &#123; $this-&gt;_gender = $gender; &#125; /** * 过滤方法 * * @param array $persons 运动员集合 * @return mixed */ public function filter(array $persons) &#123; foreach ($persons as $k =&gt; $v) &#123; if ($v-&gt;gender === $this-&gt;_gender) &#123; $personsFilter[] = $persons[$k]; &#125; &#125; return $personsFilter; &#125;&#125;/** * 按运动项目过滤实体 */class FilterSportType implements FilterInterface&#123; /** * 按照本运动项目过滤 * @var string */ private $_sportType = ''; /** * 构造函数 * @param string $sportType */ public function __construct($sportType='') &#123; $this-&gt;_sportType = $sportType; &#125; /** * 过滤方法 * * @param array $persons 运动员集合 * @return mixed */ public function filter(array $persons) &#123; foreach ($persons as $k =&gt; $v) &#123; if ($v-&gt;sportType === $this-&gt;_sportType) &#123; $personsFilter[] = $persons[$k]; &#125; &#125; return $personsFilter; &#125;&#125;try &#123; // 定义一组运动员 $persons = []; echo '&lt;pre/&gt;'; $persons[] = new SportsPerson('male', 'basketball'); $persons[] = new SportsPerson('female', 'basketball'); $persons[] = new SportsPerson('male', 'football'); $persons[] = new SportsPerson('female', 'football'); $persons[] = new SportsPerson('male', 'swim'); $persons[] = new SportsPerson('female', 'swim'); // 按过滤男性 $filterGender = new FilterGender('male'); var_dump($filterGender-&gt;filter($persons)); // 过滤运动项目篮球 $filterSportType = new FilterSportType('basketball'); var_dump($filterSportType-&gt;filter($persons));&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-代理]]></title>
    <url>%2F2017%2F03%2F28%2F2017-03-28-proxy%2F</url>
    <content type="text"><![CDATA[适用性 对对象加以【控制】 和适配器的区别：适配器是连接两个接口（【改变】了接口） 和装饰器的区别：装饰器是对现有的对象包装（【功能扩展】 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 鞋接口 */interface ShoesInterface&#123; public function product();&#125;/** * 滑板鞋实体 */class ShoesSkateboard implements ShoesInterface&#123; public function product() &#123; echo "生产一滑板鞋"; &#125;&#125;/** * 运动鞋实体 */class ShoesSport implements ShoesInterface&#123; public function product() &#123; echo "生产一双球鞋"; &#125;&#125;/** * 代理工厂 */class Proxy&#123; /** * 产品生产线对象 */ private $_shoes; /** * 产品生产线类型 */ private $_shoesType; /** * 构造函数. */ public function __construct($shoesType) &#123; $this-&gt;_shoesType = $shoesType; &#125; /** * 生产. */ public function product() &#123; switch ($this-&gt;_shoesType) &#123; case 'sport': echo "我可以偷点工"; $this-&gt;_shoes = new ShoesSport(); break; case 'skateboard': echo "我可以减点料"; $this-&gt;_shoes = new ShoesSkateboard(); break; default: throw new Exception("shoes type is not available", 404); break; &#125; $this-&gt;_shoes-&gt;product(); &#125;&#125;try &#123; echo "未加代理之前：\n"; // 生产运动鞋 $shoesSport = new ShoesSport(); $shoesSport-&gt;product(); echo "\n--------------------\n"; //----------------------------------- echo "加代理：\n"; $proxy = new Proxy('sport'); $proxy-&gt;product();&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-组合]]></title>
    <url>%2F2017%2F03%2F27%2F2017-03-27-composite%2F</url>
    <content type="text"><![CDATA[适用性 定义：将对象以树形结构组织起来，以达成“部分－整体”的层次结构，使得客户端对单个对象和组合对象的使用具有一致性 我的理解：把对象构建成树形结构 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/** * 根节点和树节点都要实现的接口 */interface CompositeInterface&#123; /** * 增加一个节点对象 * * @return mixed */ public function add(CompositeInterface $composite); /** * 删除节点一个对象 * * @return mixed */ public function delete(CompositeInterface $composite); /** * 实体类要实现的方法 * * @return mixed */ public function operation(); /** * 打印对象组合 * * @return mixed */ public function printComposite();&#125;/** * 文件实体. */class File implements CompositeInterface&#123; /** * 文件名称. * * @var string */ private $_name = ''; /** * 文件内容. * * @var string */ private $_content = ''; /** * 构造函数. * * @param string $name */ public function __construct($name = '') &#123; $this-&gt;_name = $name; &#125; /** * 魔法函数 * @param string $name 属性名称 * @return mixed */ public function __get($name='') &#123; $name = '_' . $name; return $this-&gt;$name; &#125; /** * 增加一个节点对象 * * @return mixed */ public function add(CompositeInterface $composite) &#123; throw new Exception('not support', 500); &#125; /** * 删除节点一个对象 * * @return mixed */ public function delete(CompositeInterface $composite) &#123; throw new Exception('not support', 500); &#125; /** * 打印对象组合. * * @return mixed */ public function printComposite() &#123; throw new Exception('not support', 500); &#125; /** * 实体类要实现的方法. * * @return mixed */ public function operation($operation = '', $content = '') &#123; switch ($operation) &#123; case 'write': $this-&gt;_content .= $content; echo 'write success'; break; case 'read': echo $this-&gt;_content; break; default: throw new \Exception("not support", 400); break; &#125; &#125;&#125;/** * 文件夹实体 */class Folder implements CompositeInterface&#123; /** * 对象组合 * @var array */ private $_composite = []; /** * 文件夹名称 * @var string */ private $_name = ''; /** * 构造函数 * * @param string $name */ public function __construct($name='') &#123; $this-&gt;_name = $name; &#125; /** * 魔法函数 * @param string $name 属性名称 * @return mixed */ public function __get($name='') &#123; $name = '_' . $name; return $this-&gt;$name; &#125; /** * 增加一个节点对象 * * @return void */ public function add(CompositeInterface $composite) &#123; if (in_array($composite, $this-&gt;_composite, true)) &#123; return; &#125; $this-&gt;_composite[] = $composite; &#125; /** * 删除节点一个对象 * * @return void */ public function delete(CompositeInterface $composite) &#123; $key = array_search($composite, $this-&gt;_composite, true); if (!$key) &#123; throw new Exception("not found", 404); &#125; unset($this-&gt;_composite[$key]); $this-&gt;_composite = array_values($this-&gt;_composite); &#125; /** * 打印对象组合 * * @return void */ public function printComposite() &#123; foreach ($this-&gt;_composite as $v) &#123; if ($v instanceof Folder) &#123; echo '---' . $v-&gt;name . "---\n"; $v-&gt;printComposite(); continue; &#125; echo $v-&gt;name . "\n"; &#125; &#125; /** * 实体类要实现的方法 * * @return mixed */ public function operation() &#123; return; &#125;&#125;try &#123; // 构建一个根目录 $root = new Folder('根目录'); // 根目录下添加一个test.php的文件和usr,mnt的文件夹 $testFile = new File('test.php'); $usr = new Folder('usr'); $mnt = new Folder('mnt'); $root-&gt;add($testFile); $root-&gt;add($usr); $root-&gt;add($mnt); $usr-&gt;add($testFile);// usr目录下加一个test.php的文件 // 打印根目录文件夹节点 $root-&gt;printComposite();&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-装饰器]]></title>
    <url>%2F2017%2F03%2F26%2F2017-03-26-decorator%2F</url>
    <content type="text"><![CDATA[适用性 对现有的对象增加功能 和适配器的区别：适配器是连接两个接口，装饰器是对现有的对象包装 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 鞋接口 */interface ShoesInterface&#123; public function product();&#125;/** * 装饰器抽象类. */abstract class Decorator implements ShoesInterface&#123; /** * 产品生产线对象 */ protected $shoes; /** * 构造函数. */ public function __construct(ShoesInterface $shoes) &#123; $this-&gt;shoes = $shoes; &#125; /** * 生产. */ public function product() &#123; $this-&gt;shoes-&gt;product(); &#125; /** * 装饰操作. */ abstract public function decorate($value);&#125;/** * 贴标装饰器 */class DecoratorBrand extends Decorator&#123; private $_brand; /** * 构造函数 */ public function __construct(ShoesInterface $phone) &#123; $this-&gt;phone = $phone; &#125; public function __set($name='', $value='') &#123; $this-&gt;$name = $value; &#125; /** * 生产 */ public function product() &#123; $this-&gt;phone-&gt;product(); $this-&gt;decorate($this-&gt;_brand); &#125; /** * 贴标操作 */ public function decorate($value='') &#123; echo "贴上&#123;$value&#125;标志 \n"; &#125;&#125;/** * 滑板鞋实体 */class ShoesSkateboard implements ShoesInterface&#123; public function product() &#123; echo "生产一滑板鞋"; &#125;&#125;/** * 运动鞋实体 */class ShoesSport implements ShoesInterface&#123; public function product() &#123; echo "生产一双球鞋"; &#125;&#125;try &#123; echo "未加装饰器之前：\n"; // 生产运动鞋 $shoesSport = new ShoesSport(); $shoesSport-&gt;product(); echo "\n--------------------\n"; echo "加贴标装饰器：\n"; // 初始化一个贴商标适配器 $DecoratorBrand = new DecoratorBrand(new ShoesSport()); $DecoratorBrand-&gt;_brand = 'nike'; // 生产nike牌运动鞋 $DecoratorBrand-&gt;product();&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-配制器]]></title>
    <url>%2F2017%2F03%2F25%2F2017-03-25-adapter%2F</url>
    <content type="text"><![CDATA[适用性 把实现了不同接口的对象通过适配器的方式组合起来放在一个新的环境 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * 普通媒体接口 */interface MediaInterface&#123; public function play($file='');&#125;/** * 高级媒体接口 */interface MediaAdvanceInterface&#123; public function playMp4($file=''); public function playWma($file='');&#125;/** * 高级播放器适配器 */class Adapter&#123; private $_advancePlayerInstance; private $_type = ''; public function __construct($type='') &#123; switch ($type) &#123; case 'mp4': $this-&gt;_advancePlayerInstance = new AdvanceMp4Player(); break; case 'wma': $this-&gt;_advancePlayerInstance = new AdvanceWmaPlayer(); break; default: throw new Exception("$type is not supported", 400); break; &#125; $this-&gt;_type = $type; &#125; public function play($file='') &#123; switch ($this-&gt;_type) &#123; case 'mp4': $this-&gt;_advancePlayerInstance-&gt;playMp4($file); break; case 'wma': $this-&gt;_advancePlayerInstance-&gt;playWma($file); break; default: break; &#125; &#125;&#125;/** * mp4高级播放器实体 */class AdvanceMp4Player implements MediaAdvanceInterface&#123; public function playMp4($file='') &#123; echo 'AdvanceMp4Player driver playing file: ' . $file . ".mp4\n"; &#125; public function playWma($file='') &#123; //do nothing &#125;&#125;/** * wma高级播放器实体 */class AdvanceWmaPlayer implements MediaAdvanceInterface&#123; public function playMp4($file='') &#123; //do nothing &#125; public function playWma($file='') &#123; echo 'AdvanceWmaPlayer driver playing file: ' . $file . ".wma\n"; &#125;&#125;/** * 音频设备实体 */class AudioPlayer implements MediaInterface&#123; public function play($file='', $type='') &#123; switch ($type) &#123; case 'mp3': echo 'playing file: ' . $file . ".mp3\n"; break; case 'mp4': $adapter = new Adapter($type); $adapter-&gt;play($file); break; case 'wma': $adapter = new Adapter($type); $adapter-&gt;play($file); break; default: throw new Exception("$type is not supported", 400); break; &#125; &#125;&#125;try &#123; //生产一台设备 $mp4 = new AudioPlayer(); // 播放一个mp3 $mp4-&gt;play('忍者', 'mp3'); // 播放一个wma $mp4-&gt;play('彩虹', 'wma'); // 播放一个mp4 $mp4-&gt;play('龙卷风mv', 'mp4');&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-外观]]></title>
    <url>%2F2017%2F03%2F22%2F2017-03-22-facade%2F</url>
    <content type="text"><![CDATA[适用性 把系统中类的调用委托给一个单独的类，对外隐藏了内部的复杂性，很有依赖注入容器的感觉哦 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 动物接口 */interface AnimalInterface&#123; /** * 生产方法 * * @return string */ public function produce();&#125;/** * 实体鸡工厂 */class Chicken implements AnimalInterface&#123; /** * 生产鸡 * * @return string */ public function produce() &#123; echo "生产了一只鸡~ \n"; &#125;&#125;/** * 实体猪工厂 */class Pig implements AnimalInterface&#123; /** * 生产猪 * * @return string */ public function produce() &#123; echo "生产了一只猪~ \n"; &#125;&#125;/** * 外观类 */class AnimalMaker&#123; /** * 鸡实工厂例 * @var object */ private $_chicken; /** * 猪实工厂例 * @var object */ private $_pig; /** * 构造函数 * * @return void */ public function __construct() &#123; $this-&gt;_chicken = new Chicken(); $this-&gt;_pig = new Pig(); &#125; /** * 生产方法 * * 生产鸡 * @return string */ public function produceChicken() &#123; $this-&gt;_chicken-&gt;produce(); &#125; /** * 生产方法 * * 生产猪 * @return string */ public function producePig() &#123; $this-&gt;_pig-&gt;produce(); &#125;&#125;// 初始化外观类$animalMaker = new AnimalMaker();// 生产一只猪$animalMaker-&gt;producePig();// 生产一只鸡$animalMaker-&gt;produceChicken();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-享元]]></title>
    <url>%2F2017%2F03%2F21%2F2017-03-21-flyweight%2F</url>
    <content type="text"><![CDATA[适用性 php享元（轻量级）模式 就是缓存了创建型模式创建的对象，不知道为什么会归在结构型模式中，个人觉得创建型模式更合适，哈哈～ 其次，享元强调的缓存对象，外观模式强调的对外保持简单易用，是不是就大体构成了目前牛逼哄哄且满大的街【依赖注入容器】 下面我们借助最简单的’工厂模式‘来实现享元模式，就是给工厂加了个缓存池 UML 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151/** * 农场 * * 生产动物 */class Farm&#123; /** * 对象缓存池 * @var array */ private $_farmMap = []; /** * 构造函数 */ public function __construct() &#123; echo "-----------初始化了一个农场----------- \n\n"; &#125; /** * 生产方法 * * 生产农物 * * @param string $type 农场类型 * @return mixed */ public function produce($type='') &#123; // 对象缓存池判断 if (key_exists($type, $this-&gt;_farmMap)) &#123; echo "来自缓存池-&gt; "; return $this-&gt;_farmMap[$type];// 返回缓存 &#125; switch ($type) &#123; case 'chicken': return $this-&gt;_farmMap[$type] = new Chicken(); break; case 'pig': return $this-&gt;_farmMap[$type] = new Pig(); break; default: echo "该农场不支持生产该农物~ \n"; break; &#125; &#125;&#125;/** * 动物接口 */interface AnimalInterface&#123; /** * 类型获取 * * @return string */ public function getType();&#125;/** * 实体鸡 * */class Chicken implements AnimalInterface&#123; /** * 类别 * @var string */ private $_type = ''; /** * 构造函数 */ public function __construct() &#123; &#125; /** * 类型获取 * * @return string */ public function getType() &#123; echo "这是只鸡～ \n"; &#125;&#125;/** * 实体猪 * */class Pig implements AnimalInterface&#123; /** * 类别 * @var string */ private $_type = ''; /** * 构造函数 */ public function __construct() &#123; &#125; /** * 类型获取 * * @return string */ public function getType() &#123; echo "这是只猪～ \n"; &#125;&#125;// 初始化一个工厂$farm = new Farm();//-----------初始化了一个农场----------- // 成产一只鸡$farm-&gt;produce('chicken')-&gt;getType();//这是只鸡～// 再生产一只鸡$farm-&gt;produce('chicken')-&gt;getType();//来自缓存池-&gt; 这是只鸡～// 成产一只猪$farm-&gt;produce('pig')-&gt;getType();//这是只猪～// 再生产一只猪$farm-&gt;produce('pig')-&gt;getType();//来自缓存池-&gt; 这是只猪～]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-桥接]]></title>
    <url>%2F2017%2F03%2F09%2F2017-03-09-bridge%2F</url>
    <content type="text"><![CDATA[适用性 基础的结构型设计模式：将抽象和实现解耦,对抽象的实现是实体行为对接口的实现。 例如：人 =&gt; 抽象为属性：性别 动作：吃 =&gt; 人吃的动作抽象为interface =&gt; 实现不同的吃法。 UML 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 人抽象类 */abstract class PersonAbstract&#123; /** * 性别 * @var string */ protected $_gender = ''; /** * 使用的吃饭工具 * @var string */ protected $_tool = ''; /** * 构造函数 * * @param string $gender 性别 * @param EatInterface $tool [description] */ public function __construct($gender='',EatInterface $tool) &#123; $this-&gt;_gender = $gender; $this-&gt;_tool = $tool; &#125; /** * 吃的行为 * * @param string $food 实物 * @return void */ abstract public function eat($food='');&#125;/** * 男人实类 */class PersonMale extends PersonAbstract&#123; /** * 吃的具体方式 * * @param string $food 食物 * @return string */ public function eat($food='') &#123; $this-&gt;_tool-&gt;eat($food); &#125;&#125;/** * 吃接口 */interface EatInterface&#123; /** * 吃 * * @param string $food 食物 * @return mixed */ public function eat($food='');&#125;/** * 用叉子吃实体 */class EatByFork implements EatInterface&#123; /** * 吃 * * @param string $food 食物 * @return string */ public function eat($food='') &#123; echo "用叉子吃&#123;$food&#125;~"; &#125;&#125;/** * 用筷子吃实体 */class EatByChopsticks implements EatInterface&#123; /** * 吃 * * @param string $food 食物 * @return string */ public function eat($food='') &#123; echo "用筷子吃&#123;$food&#125;~"; &#125;&#125;try &#123; // 初始化一个用筷子吃饭的男人的实例 $male = new PersonMale('male', new EatByChopsticks()); // 吃饭 $male-&gt;eat('大米');&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找数字-网易校招]]></title>
    <url>%2F2017%2F02%2F05%2F2017-2-05-FindNumber%20%2F</url>
    <content type="text"><![CDATA[题目描述给定一个数组，除了第一个出现1次之外，其余全都出现3次。找出出现一次的值。如：{1, 2, 1, 2, 1, 2, 7}, 找出7. 分析与解法我们以数组[1, 2, 3, 1, 2, 1, 2]举例，将数组元素用二进制表示： 12345670 11 01 10 11 00 11 0 如果理解了上题，此题的思路似乎也就呼之欲出了。我们也可以按位运算，计算1 bit的数量，如果每个数字都出现三次，那么每位上的1 bit数量肯定是3的倍数，相反如果不是3的倍数，那么就是那个特殊的数在捣蛋。 我们似乎需要这么一种“加法”运算，使得每位上的 1 bit 数量能够得到累计，并且累计到了3就自动清零。但是理想是美好的，现实是残酷的，并没有这样一种神奇的运算（三进制？）。 但是我们可以用一个数“辅助”，因为每一位的1 bit数量统计都是类似的，所以假设正在统计某一位的1 bit数量。我们用a来表示 1 bit 的数量，当 1 bit的数量为0时，a=0；当数量为1时，a=1；当数量为2时，a=2？非也，位运算只能表示0和1，所以这时我们引进第二个变量b，我们用b=1来代表已经有了2个 1 bit，所以当有两个 1 bit 时，a=0,b=1。数量统计结果逢3化0，所以只有0、1、2三种结果： 1234bits数量 a b 0 0 0 1 1 0 2 0 1 思路也就显而易见了，每次运算我们维护a和b的值，运算到最后即可得到结果： 12345678$c = array(1, 2, 1, 2, 1, 2, 7);$a = 0;$b = 0;for ($i=0; $i &lt; count($c); $i++) &#123; $b = $a &amp; ($b ^ $c[$i]); $a = $b | ($a ^ $c[$i]);&#125;echo $a; 7]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-原型]]></title>
    <url>%2F2016%2F12%2F22%2F2016-12-22-prototype%2F</url>
    <content type="text"><![CDATA[适用性原型设计模式创建对象的方式是复制和克隆初始对象或原型，这种方式比创建新实例更为有效。 UML MyOject 类组合使用了原型设计模式。这个类具有名为 requestClone() 的公共方法，该方法用于生产 MyObject 实例的一个副本。 CloneObject 对象表示 MyObject 的复制实例。需要注意的是，因为该对象实际是一个复制品，所有它具有 requestClone()方法。 通过调用MyObject 的 requestClone() 方法，可以创建 CloneObject 的许多实例。 代码示例音乐销售 Wed 站点允许登录站点的艺术家创建许多乐队的音乐“合辑”。目前，这种功能性还限制为所有有效的音轨只能来自一个乐队。为了开始创建CD“合辑”，我们可以采用多种途径。其中，在访问者查看某乐队的CD 页面的时候可以使用最通用的选项。CD页面存在的某个链接能够启动构建新CD“合辑”的进程，该进程会发送一个ID，这个ID对应于乐队的特定CD。上面这个进程的第一个构建代码块是CD类。通类，为了构建CD对象，需要从数据库中检索出与被请求ID匹配的具体信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class CD&#123; public $band = ''; public $tranckList = array(); public function _construct($id) &#123; $handle = mysql_connect('localhost','user','pass'); mysql_select_db('cd',$handle); $query = "select band , title from CDs where id=&#123;$id&#125;"; $resulte = mysql_query($query , $handle); if ($row = mysql_fetch_array($resulte)) &#123; $this-&gt;band = $row['band']; $this-&gt;title = $row['title']; &#125; &#125; public function buy() &#123; //cd buying magic here echo '&lt;pre&gt;'; var_dump($this); &#125;&#125;~~~ 这个类具有标砖的公共属性 $band $title $trackList &lt;br/&gt;构造函数接受 $id 参数 ID ，并且针对数据库执行查询。当发现指定ID时，相对应乐队和标题会分别指派给公共属性 $band 和 $title .&lt;br/&gt;此外，CD类还增加了一个 buy() 函数。在最后的代码中，该方法可以处理CD 对象提供用于购买。&lt;br/&gt;下一个需要创建的类代表混合CD 实体。这种特点的对象利用了PHP 的克隆能力:~~~ phpclass MixtapeCD extends CD&#123; public function __clone() &#123; $this-&gt;title = 'Mixtape'; &#125;&#125; MixtapeCD 实际只是一种特殊化CD ， 扩展了CD 对象。执行PHP 的 clone 命令是，就会对指定的对象执行 _clone() 方法。在MixtapeCD 对象中，初始CD的属性被重写。这个 MixtapeCD 对象不再对应于一个乐队和标题的CD 组合。此时，该对象关联 $band , 但具有新的标题 Mixtape 。下面展示了某用户基于制定乐队制定两个混合标题的情况: 12345678910111213$externalPurchaseInfoBandID = 12;$bandMixProto = new MixtapeCD($externalPurchaseInfoBandID);$externalPurchaseInfo = array();$externalPurchaseInfo[] = array('brrr' , 'goodbye');$externalPurchaseInfo[] = array('what it means','brrr');foreach ($externalPurchaseInfo as $mixed) &#123; $cd = clone $bandMixProto; $cd-&gt;trackList = $mixed; $cd-&gt;buy();&#125; $bandMixProto 对象根据 MixtapeCD 的新实例创建的。传递该对象的参数 $extemalPuchaseInfoBandID 被用于实际 CD类构造函数执行的查询。一旦创建了原型，就能够循环遍历用于特定访问者的CD合辑的音轨列表。对于 foreach() 循环的每个实例来说， $cd 都指派给 $bandMixProto 新副本。接下来特定曲目列表会被添加指定的对象。因为使用了克隆技术，所以每个新的循环都不需要针对数据库新查询。克隆对象已经存储了所有信息，最后，通过执行方法 buy() 就可以购买制定的 $cd 对象。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-建造]]></title>
    <url>%2F2016%2F12%2F16%2F2016-12-16-builder%2F</url>
    <content type="text"><![CDATA[适用性 建造者设计模式定义了处理其他对象的复杂构建的对象设计 UML 代码示例具体项目包含一个创建复杂产品对象的类，这个类包含完整构成对象的三个方法。如果在创建新产品对象时没有调用其中一个方法，那么类的属性便会失去。并且程序也会中断。这三个方法setType() setColor() serSize()。如下面的代码所示，最早版本的代码呗设计为先创建产品对象。然后再执行上述三个方法。 1234567891011121314151617181920class product&#123; protected $_type = '' ; protected $_size = '' ; protected $_color = '' ; public function setType($type) &#123; $this-&gt;_type = $type; &#125; public function setSize($size) &#123; $this-&gt;_size = $size; &#125; public function setColor($color) &#123; $this-&gt;_color = $color; &#125;&#125; 为了创建完整的产品对象，需要将产品配置分别传递产品类的每个方法： 123456$productConfigs = array('type'=&gt;'shirt','size'=&gt;'XL','color'=&gt;'red');$product = new product();$product-&gt;setType($productConfigs['type']);$product-&gt;setSize($productConfigs['size']);$product-&gt;setColor($productConfigs['color']); 创建对象时分别调用每个方法并不是最佳的做法。此时，我们最好使用基于建造者设计模式的对象来创建这个产品实例。 producBuilder 类被设计为接受构建 product 对象所需的这些配置选项。 它不仅存储配置参数，而且存储一个实例化的新 product 实例，build() 方法负责调用 product 类中的所有方法，从而构建完整的 product 对象。最后，getProduct() 方法返回完整构建的 product 对象。 1234567891011121314151617181920212223class productBuilder&#123; protected $_product = null; protected $_configs = array(); public function __construct($configs) &#123; $this-&gt;_product = new product(); $this-&gt;_configs = $configs; &#125; public function build() &#123; $this-&gt;_product-&gt;setSize($this-&gt;_configs['size']); $this-&gt;_product-&gt;setType($this-&gt;_configs['type']); $this-&gt;_product-&gt;setColor($this-&gt;_configs['color']); &#125; public function getProduct() &#123; return $this-&gt;_product; &#125;&#125; 需要注意的是，build() 方法隐藏了来自请求新 product 对象的代码的实际方法调用。如果 product 类以后发生改变，那么只需要修改 productBuilder 类的 build() 方法，下面的代码说明了如何使用 productBuilder 类创建 product 对象： 123$builder = new productBuilder($productConfigs);$builder-&gt;build();$product = $builder-&gt;getProduct(); 建造者设计模式的目的是消除其他对象的复杂创建的过程。使用建造者设计模式不仅是最近的做法。而且在某个对象的构造和配置方法改变时可以尽可能的减少重复更改代码。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转字符串]]></title>
    <url>%2F2016%2F12%2F13%2F2016-12-13-ReverseString%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能。禁止使用字符串函数! 分析与解法将一个字符串分成X和Y两个部分，在每部分字符串上定义反转操作，如X^T，即把X的所有字符反转（如，X=”abc”，那么X^T=”cba”），那么就得到下面的结论：(X^TY^T)^T=YX，显然就解决了字符串的反转问题。 例如，字符串 abcdef ，若要让cdef翻转到ab的前头，只要按照下述3个步骤操作即可： 首先将原字符串分为两个部分，即X:ab，Y:cdef； 将X反转，X-&gt;X^T，即得：ab-&gt;ba；将Y反转，Y-&gt;Y^T，即得：cdef-&gt;fedc。 反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（ba和fedc）给予反转，bafedc得到cdefab，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。 1234567891011121314151617181920212223242526function ReverseString(&amp;$s, $from, $to)&#123; while ($from &lt; $to) &#123; $t = $s[$from]; $s[$from++] = $s[$to]; $s[$to--] = $t; &#125;&#125;function LeftRotateString(&amp;$s,$n,$m)&#123; $m %= $n; ReverseString($s, 0, $m - 1); // echo $s; //bacdef ReverseString($s, $m, $n - 1); // echo $s; //bafedc ReverseString($s, 0, $n - 1); // echo $s; //cdefab&#125;$String = 'abcdef';$n = 6;$m = 2;LeftRotateString($String,$n,$m);// echo $String; //cdefab 举一反三 链表翻转。给出一个链表和一个数k，比如，链表为1→2→3→4→5→6，k=2，则翻转后2→1→6→5→4→3，若k=3，翻转后3→2→1→6→5→4，若k=4，翻转后4→3→2→1→6→5，用程序实现。 编写程序，在原字符串中把字符串尾部的m个字符移动到字符串的头部，要求：长度为n的字符串操作时间复杂度为O(n)，空间复杂度为O(1)。 例如，原字符串为”Ilovebaofeng”，m=7，输出结果为：”baofengIlove”。 反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-单例]]></title>
    <url>%2F2016%2F12%2F10%2F2016-12-10-singleton%2F</url>
    <content type="text"><![CDATA[“two day~ ” 适用性 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。 UML 代码示例CD wed站点出售CD。在访问者购买后要及时更新库存。为了实现这个功能。需要链接MySQL 数据库以及更新CD数量。使用变相对象的方式。可能要创造多个不必要的数据库链接。如下所示，完全可以选择单例模式的数据库链接： 123456789101112131415161718192021222324252627282930class InventoryConnection&#123; protected static $_instance = null; protected $_handle = null; public static function getInstance() &#123; if(!self::$_instance instanceof self) &#123; self::$_instance = new self; &#125; return self::$_instance; &#125; protected function __construct() &#123; $this-&gt;_handle = mysql_connect('localhose','user','pass'); mysql_select_db('cd',$this-&gt;_handle); &#125; public function updateQuantity($band,$title,$number) &#123; $query = "update CDS set amount=amount+".intval($number); $query .= " where band =' ".mysql_real_escape_string($band)." ' "; $query .= " and title =' ".mysql_real_escape_string($title)." ' " ; mysql_query($query,$this-&gt;_handle); &#125;&#125; InventoryConnection 类的第一个公共方法 getInstance()的静态方法。这个方法检查$_instance 是否有实例。接下来就是购买CD. 1234567891011121314151617class CD&#123; protected $_title = ''; protected $_band = ''; public function __construct($title,$band) &#123; $this-&gt;_title = $title; $this-&gt;_band = $band; &#125; public function buy() &#123; $inventory = InventoryConnection::getInstance(); $inventory-&gt;updateQuantity($this-&gt;_band, $this-&gt;_title,-1); &#125; &#125; 通过调用InventoryConnection 的getInstance() 方法来获得这个类的实例。一旦接收实例，就会调用通过调用InventoryConnection 对象updateQuantity()方法指定CD数量减1。 123456789$boughtCDs = array();$boughtCDs[] = array('band'=&gt;'Never Again','Waste of a Rib');$boughtCDs[] = array('banc'=&gt;'Therappee','Long Road');foreach ($boughtCDs as $boughtCD)&#123; $cd = new CD($boughtCD['title'],$boughtCD['banc']); $cd-&gt;buy();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式-工厂]]></title>
    <url>%2F2016%2F12%2F09%2F2016-12-09-factory%20%2F</url>
    <content type="text"><![CDATA[“one day~ ” 瞎BBZiv 的 Blog 就这么开通了。 2016 年末，Ziv 总算有个地方可以随便写点东西了。 一直想找个地方，把自己看到的学到的东西都写写。Blog 这个东西一直惦记好久了。最近才发现了githup + jekyll 这地方。本来准备用HEXO的。后来觉得jekyll 的模板好看。我就又用这个了。花了漫长的时间去弄的。本来在WIN上玩Ruby 就不是太舒服。后来自己搭了个虚拟机Ubuntu。才觉得顺手了。 一直觉得自己技术不是很扎实，所以最近一直在补PHP基础。所以就刚好随便写写。 适用性工厂设计模式提供获取某个对象的新实例的一个接口，同时使调用代码避免确定实际实例化基类的步骤。 UML 代码示例为了管理控制CD，应用程序需要将必要的信息编辑入CD 对象。然后传递出去。完成CD创建工作。CD 对象需要包含标题，乐队名称，曲目列表。 123456789101112131415161718192021222324252627class cd&#123; public $title = ''; public $band = ''; public $track = array(); public function __construct() &#123; &#125; public function setTitle($title) &#123; $this-&gt;title = $title; &#125; public function setBand($band) &#123; $this-&gt;band = $band; &#125; public function addTrack($track) &#123; $this-&gt;track[] = $track; &#125;&#125; 为了创建完整的CD对象。处理过程相同: 创建一个CD类的实例，然后添加标题，乐队名称，曲目列表。 12345678910$title = 'Waste of a Rib';$band = 'Never Again';$tracksFromExternalSoutce = array('What It Means','Brrr','Goodbye');$cd = new CD();$cd-&gt;setTitle($title);$cd-&gt;setBand($band);foreach ($tracksFromExternalSoutce as $track )&#123; $cd-&gt;addTrack($track);&#125; 输出： 123456789101112131415object(cd)#1 (3) &#123; ["title"]=&gt; string(14) "Waste of a Rib" ["band"]=&gt; string(11) "Never Again" ["track"]=&gt; array(3) &#123; [0]=&gt; string(13) "What It Means" [1]=&gt; string(4) "Brrr" [2]=&gt; string(7) "Goodbye" &#125;&#125; 如今，某些艺术家在他们的CD上发布了在计算机中能够使用的其他内容。这些CD称为增强型CD。写至光盘的第一个音轨是数据音轨。管理控制软件通过其他标签DATA TRACK识别数据音轨，并且创建相应的CD对象。 1234567891011121314151617181920212223242526class enhancedCD&#123; public $title = ''; public $band = ''; public $track = array(); public function __construct() &#123; $this-&gt;track[] = 'DATA TRACK'; &#125; public function setTitle($title) &#123; $this-&gt;title = $title; &#125; public function setBand($band) &#123; $this-&gt;band = $band; &#125; public function addTrack($track) &#123; $this-&gt;track[] = $track; &#125;&#125; 查看上述共性和认识到只可能存在两种CD类型之后，似乎我们只需要创造条件语句。如果CD类型是增强型CD，那么就创建enhancedCD类的实例。否则，就应创建通用CD类。然而更好的解决方案：使用工厂设计模式。CDFactory类使用了PHP根据比变量动态实例化一个类的能力。create()方法接受被请求类的类型并返回类的一个实例： 123456789class CDFactry&#123; public static function create($type) &#123; $class = strtolower($type).'CD'; return new $class; &#125;&#125; 现在，类的创建和执行变化反应了Factory 类的用法： 1234567$type = 'enhanced';$cd = CDFactry::create($type);$cd-&gt;setBand($band);$cd-&gt;setTitle($title);foreach ($tracksFromExternalSoutce as $track )&#123; $cd-&gt;addTrack($track);&#125; 输出： 1234567891011121314151617object(enhancedCD)#2 (3) &#123; ["title"]=&gt; string(14) "Waste of a Rib" ["band"]=&gt; string(11) "Never Again" ["track"]=&gt; array(4) &#123; [0]=&gt; string(10) "DATA TRACK" [1]=&gt; string(13) "What It Means" [2]=&gt; string(4) "Brrr" [3]=&gt; string(7) "Goodbye" &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
